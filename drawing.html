<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Drawing App Pro - Final Edition</title>
  <!-- Google Identity Services -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <style>
    :root {
      /* Современная цветовая палитра */
      --color-bg: #f9fafc;
      --color-sidebar: #ffffff;
      --color-panel: #ffffff;
      --color-border: #d8dee4;
      --color-text: #24292f;
      --color-primary: #2563eb;
      --color-secondary: #10b981;
      --color-accent: #f97316;
      --color-danger: #ef4444;
      --font-family: "Inter", sans-serif;
      --transition-speed: 0.2s;
      --sidebar-width: 320px;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      display: flex;
      background: var(--color-bg);
      font-family: var(--font-family);
      color: var(--color-text);
    }
    /* -------------- Левая панель -------------- */
    .sidebar {
      flex: 0 0 var(--sidebar-width);
      background: var(--color-sidebar);
      border-right: 1px solid var(--color-border);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      box-shadow: 2px 0 5px rgba(0,0,0,0.05);
      position: sticky;
      top: 0;
      height: 100vh;
      overflow-y: auto;
    }
    .sidebar-header {
      position: sticky;
      top: 0;
      background: var(--color-sidebar);
      padding-bottom: 8px;
      z-index: 10;
    }
    .sidebar-header h2 { font-size: 1.2rem; color: var(--color-primary); }
    .version { font-size: 0.85rem; color: #999; }
    /* Панель инструментов – на русском */
    .toolbar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .icon {
      width: 48px;
      height: 48px;
      background: #fff;
      border: 2px solid var(--color-border);
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: transform var(--transition-speed), background var(--transition-speed), border-color var(--transition-speed);
      user-select: none;
    }
    .icon:hover { background: var(--color-primary); border-color: var(--color-primary); transform: scale(1.07); }
    .icon.active { background: var(--color-accent); border-color: var(--color-accent); transform: scale(1.07); }
    .icon svg {
      width: 24px; height: 24px;
      fill: var(--color-text);
      transition: fill var(--transition-speed);
    }
    .icon:hover svg, .icon.active svg { fill: #fff; }
    /* Секция "Слои" */
    .layers-header { font-size: 1.2rem; color: var(--color-primary); margin-bottom: 4px; }
    .layer-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }
    .btn-undo-redo {
      width: 48px;
      height: 48px;
      background: #fff;
      border: 2px solid var(--color-border);
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: transform var(--transition-speed), background var(--transition-speed), border-color var(--transition-speed);
    }
    .btn-undo-redo:hover { background: var(--color-primary); border-color: var(--color-primary); transform: scale(1.07); }
    .btn-undo-redo svg {
      width: 24px;
      height: 24px;
      fill: var(--color-text);
      transition: fill var(--transition-speed);
    }
    .btn-undo-redo:hover svg { fill: #fff; }
    .layers {
      flex: 1;
      border: 1px solid var(--color-border);
      border-radius: 6px;
      padding: 8px;
      background: #fff;
      overflow-y: auto;
    }
    .layer-item {
      display: flex;
      align-items: center;
      border-radius: 6px;
      background: #f3f4f6;
      margin-bottom: 6px;
      padding: 8px;
      cursor: move;
      transition: background var(--transition-speed), transform var(--transition-speed);
    }
    .layer-item:hover { background: #e2e3e5; transform: scale(1.02); }
    .layer-item.selected { background: var(--color-accent); color: #fff; }
    .delete-layer-button {
      margin-left: auto;
      background: var(--color-danger);
      border: none;
      border-radius: 6px;
      padding: 4px 8px;
      color: #fff;
      cursor: pointer;
      transition: background var(--transition-speed);
    }
    .delete-layer-button:hover { background: #b91c1c; }
    #noLayersMsg { color: #666; text-align: center; margin: 6px 0; }
    /* -------------- Холст -------------- */
    .canvas-container {
      flex: 1;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 16px;
      background: var(--color-bg);
      overflow: auto;
    }
    .canvas {
      width: 900px;
      height: 600px;
      background: #fff;
      border: 1px solid var(--color-border);
      border-radius: 8px;
      position: relative;
      box-shadow: 0 3px 12px rgba(0,0,0,0.08);
      overflow: visible;
      transform-origin: 0 0;
      transition: transform 0.2s ease;
    }
    /* Zoom Controls */
    .zoom-controls {
      position: absolute;
      top: 16px;
      right: 16px;
      display: flex;
      gap: 8px;
      z-index: 1100;
    }
    .zoom-controls button {
      background: var(--color-primary);
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 6px 8px;
      cursor: pointer;
      transition: background var(--transition-speed);
    }
    .zoom-controls button:hover { background: var(--color-accent); }
    /* Фигуры */
    .shape {
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      border-style: solid;
      transform-origin: center;
      box-sizing: border-box;
      transition: box-shadow var(--transition-speed);
    }
    .shape:hover { box-shadow: 0 0 4px rgba(0,0,0,0.15); }
    .circle { border-radius: 50%; }
    .shape-text {
      min-width: 30px;
      min-height: 20px;
      white-space: pre-wrap;
      word-break: break-word;
      outline: none;
      cursor: text;
    }
    .selected { outline: 2px dashed var(--color-secondary); outline-offset: 2px; }
    /* Ручки resize/rotate */
    .resize-handle, .rotate-handle { display: none; }
    .selected .resize-handle, .selected .rotate-handle { display: block; }
    .resize-handle, .rotate-handle {
      background: var(--color-primary);
      border-radius: 50%;
      width: 12px;
      height: 12px;
    }
    .resize-handle { position: absolute; right: -6px; bottom: -6px; cursor: nwse-resize; }
    .rotate-handle { position: absolute; top: -20px; left: 50%; transform: translateX(-50%); cursor: grab; }
    /* Панель управления объектом – однострочная, появляется над объектом */
    .color-panel {
      position: absolute;
      background: var(--color-panel);
      border: 1px solid var(--color-border);
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      padding: 4px 8px;
      z-index: 1000;
      display: none;
      align-items: center;
      gap: 8px;
      font-size: 0.85rem;
    }
    .color-panel .field-group { display: flex; align-items: center; gap: 4px; }
    .color-panel label { white-space: nowrap; color: #555; }
    .color-panel input[type="color"],
    .color-panel input[type="range"],
    .color-panel input[type="number"] { max-width: 70px; }
    .color-panel button {
      background: var(--color-accent);
      border: none;
      color: #fff;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
      transition: background var(--transition-speed);
    }
    .color-panel button:hover { background: var(--color-primary); }
    /* Стрелка и ручки для стрелки */
    .arrow-container { position: absolute; pointer-events: auto; }
    .arrow-shaft { position: absolute; top: 50%; left: 0; height: 2px; transform: translateY(-50%); }
    .arrow-head { position: absolute; width: 0; height: 0; border-top: 5px solid transparent; border-bottom: 5px solid transparent; transform: translateY(-50%); }
    .arrow-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      background: var(--color-primary);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      cursor: move;
      display: none;
    }
    .arrow-container.selected .arrow-handle { display: block; }
  </style>
</head>
<body>
  <!-- Левая панель -->
  <div class="sidebar">
    <div class="sidebar-header">
      <h2>Инструменты</h2>
      <div class="version">Version 1.0.1</div>
    </div>
    <div class="toolbar">
      <!-- Порядок: Указатель, Квадрат, Круг, Стрелка, Текст -->
      <div class="icon pointer" data-shape="pointer" title="Указатель">
        <svg viewBox="0 0 16 16">
          <path d="M2 2v12l4-4 3 4 2-2-3-4 4-4H2z"/>
        </svg>
      </div>
      <div class="icon rectangle active" data-shape="rectangle" title="Квадрат">
        <svg viewBox="0 0 16 16">
          <rect x="3" y="3" width="10" height="10" rx="1" ry="1"/>
        </svg>
      </div>
      <div class="icon circle" data-shape="circle" title="Круг">
        <svg viewBox="0 0 16 16">
          <circle cx="8" cy="8" r="5"/>
        </svg>
      </div>
      <div class="icon arrow" data-shape="arrow" title="Стрелка">
        <svg viewBox="0 0 16 16">
          <path d="M2 8h9l-3.5-3.5L9 3l5 5-5 5-1.5-1.5L11 8H2z"/>
        </svg>
      </div>
      <div class="icon text" data-shape="text" title="Текст">
        <svg viewBox="0 0 16 16">
          <text x="3" y="12" font-size="10" font-family="Arial" fill="currentColor">T</text>
        </svg>
      </div>
    </div>
    <div>
      <label>
        <input type="checkbox" id="snapToGrid" />
        Привязка к сетке
      </label>
    </div>
    <div class="sidebar-header">
      <h2>Слои</h2>
    </div>
    <div class="layer-controls">
      <div id="undo" class="btn-undo-redo" title="Отменить (Undo)">
        <svg viewBox="0 0 24 24">
          <path d="M12.5 8c-2.14 0-3.86 1.72-3.86 3.86v.76L6 10v6h6l-2.64-2.64v-.5A1.86 1.86 0 0112.5 12c.86 0 1.64.56 1.84 1.4.12.5.62.8 1.14.8.08 0 .16-.01.24-.03.62-.17 1.02-.8.85-1.42A3.86 3.86 0 0012.5 8z"/>
        </svg>
      </div>
      <div id="redo" class="btn-undo-redo" title="Повторить (Redo)">
        <svg viewBox="0 0 24 24">
          <path d="M13.64 7.36A3.86 3.86 0 0010.5 6c-2.14 0-3.86 1.72-3.86 3.86 0 .62.23 1.25.68 1.84.28.38.21.93-.17 1.22-.38.28-.93.21-1.22-.17A5.78 5.78 0 014.78 9.86 5.86 5.86 0 0110.5 4c2.23 0 4.15 1.3 5.06 3.16l1.44-1.44V12h-6l2.64-2.64z"/>
        </svg>
      </div>
    </div>
    <div class="layers" id="layersList">
      <p id="noLayersMsg">Нет слоёв</p>
    </div>
    <div id="driveControls" class="form-group">
      <label>Интеграция с Google Drive</label>
      <div style="display:flex; gap:8px; margin-bottom:4px;">
        <button id="signin_button">Войти</button>
        <button id="signout_button" style="display:none;">Выйти</button>
        <button id="driveSave">Сохранить</button>
        <button id="driveOpen">Открыть</button>
      </div>
      <div id="driveFileList" style="max-height:120px; overflow-y:auto;"></div>
    </div>
  </div>

  <!-- Холст и Zoom Controls -->
  <div class="canvas-container">
    <div class="canvas"></div>
    <div class="zoom-controls">
      <button id="zoomOut">–</button>
      <button id="zoomReset">100%</button>
      <button id="zoomIn">+</button>
    </div>
    <!-- Панель управления объектом – однострочная, появляется над объектом при выделении -->
    <div id="colorPanel" class="color-panel">
      <div class="field-group"><label>Fill:</label><input type="color" id="cpFillColor" value="#ff0000" /></div>
      <div class="field-group"><label>Op:</label><input type="range" id="cpFillOpacity" min="0" max="1" step="0.1" value="1" /></div>
      <div class="field-group"><label>Border:</label><input type="color" id="cpBorderColor" value="#000000" /></div>
      <div class="field-group"><label>Op:</label><input type="range" id="cpBorderOpacity" min="0" max="1" step="0.1" value="1" /></div>
      <div class="field-group"><label>BW:</label><input type="number" id="cpBorderWidth" min="0" max="20" value="1" /></div>
      <div class="field-group"><label>W:</label><input type="number" id="cpWidth" min="0" max="2000" value="100" /></div>
      <div class="field-group"><label>H:</label><input type="number" id="cpHeight" min="0" max="2000" value="100" /></div>
      <div class="field-group"><label>Угол:</label><input type="number" id="cpAngle" min="0" max="360" value="0" /></div>
      <div class="field-group" id="textSizeGroup" style="display:none;"><label>Размер текста:</label><input type="number" id="cpFontSize" min="8" max="100" value="16" /></div>
      <button id="cpClose">Закрыть</button>
    </div>
  </div>

  <!-- Скрипты Google Drive -->
  <script>
    "use strict";
    const CLIENT_ID = "158627123477-4m4d7dqms8ndlmfq4mejhdguj1jte08m.apps.googleusercontent.com";
    const SCOPES = "https://www.googleapis.com/auth/drive.file";
    let accessToken = null;
    let tokenClient = null;
    let currentFileId = null;
    window.onload = () => {
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPES,
        callback: (tokenResponse) => {
          accessToken = tokenResponse.access_token;
          console.log("Access token получен:", accessToken);
          listFiles();
        },
      });
    };
    function handleSignInClick() {
      tokenClient.requestAccessToken({ prompt: "" });
    }
    function handleSignOutClick() {
      if (accessToken) {
        fetch("https://oauth2.googleapis.com/revoke?token=" + accessToken, {
          method: "POST",
          headers: { "Content-type": "application/x-www-form-urlencoded" }
        })
          .then(() => console.log("Token revoked"))
          .catch(err => console.error(err));
      }
      accessToken = null;
      currentFileId = null;
      document.getElementById('driveFileList').innerHTML = '';
      document.getElementById('signin_button').style.display = 'block';
      document.getElementById('signout_button').style.display = 'none';
    }
    async function listFiles() {
      if (!accessToken) {
        console.warn("Нет access token. Сначала войдите.");
        return;
      }
      try {
        const resp = await fetch("https://www.googleapis.com/drive/v3/files?pageSize=10&q=mimeType!='application/vnd.google-apps.folder'", {
          headers: { Authorization: `Bearer ${accessToken}` }
        });
        const data = await resp.json();
        const fileListElem = document.getElementById('driveFileList');
        fileListElem.innerHTML = '';
        if (data.files && data.files.length > 0) {
          data.files.forEach(file => {
            const div = document.createElement('div');
            div.classList.add('drive-file');
            div.textContent = `${file.name} (${file.id})`;
            div.style.cursor = "pointer";
            div.addEventListener('click', () => loadFromDrive(file.id));
            fileListElem.appendChild(div);
          });
        } else {
          fileListElem.innerHTML = 'Файлы не найдены.';
        }
      } catch (err) {
        console.error("Ошибка при получении списка файлов", err);
      }
    }
    async function loadFromDrive(fileId) {
      if (!accessToken) { alert("Нет access token"); return; }
      try {
        const resp = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
          headers: { Authorization: `Bearer ${accessToken}` }
        });
        const fileContent = await resp.text();
        document.querySelector('.canvas-container').innerHTML = fileContent;
        currentFileId = fileId;
        alert('Файл загружен из Drive.');
      } catch (error) { console.error('Ошибка загрузки файла', error); }
    }
    async function saveToDrive() {
      if (!accessToken) { console.warn("Нет access token для сохранения."); return; }
      if (!currentFileId) { await createFileOnDrive(); }
      else { await updateFileOnDrive(currentFileId); }
    }
    // Глобальная переменная для хранения идентификатора папки
    let driveFolderId = null;
    const DRIVE_FOLDER_NAME = "DrawingAppFiles";

    // Функция для получения или создания папки в Google Drive
    async function getOrCreateFolder(folderName) {
      // Поиск папки по имени
      const query = encodeURIComponent(`mimeType='application/vnd.google-apps.folder' and name='${folderName}' and trashed=false`);
      const url = `https://www.googleapis.com/drive/v3/files?q=${query}&fields=files(id,name)`;
      const resp = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` } });
      const data = await resp.json();
      if (data.files && data.files.length > 0) {
        return data.files[0].id;
      }
      // Если папка не найдена, создаём её
      const metadata = {
        name: folderName,
        mimeType: "application/vnd.google-apps.folder"
      };
      const form = new FormData();
      form.append("metadata", new Blob([JSON.stringify(metadata)], { type: "application/json" }));
      const createResp = await fetch("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart", {
        method: "POST",
        headers: { Authorization: `Bearer ${accessToken}` },
        body: form
      });
      const result = await createResp.json();
      return result.id;
    }

    async function createFileOnDrive() {
      try {
        // Получаем папку (создаём, если отсутствует)
        driveFolderId = await getOrCreateFolder(DRIVE_FOLDER_NAME);
        const contentHtml = document.querySelector('.canvas').outerHTML;
        const contentBlob = new Blob([contentHtml], { type: 'text/html' });
        const metadata = {
          name: 'drawing.html',
          mimeType: 'text/html',
          parents: [driveFolderId] // сохраняем в нашей папке
        };
        const form = new FormData();
        form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
        form.append('file', contentBlob);
        const resp = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
          method: 'POST',
          headers: { Authorization: `Bearer ${accessToken}` },
          body: form
        });
        const result = await resp.json();
        currentFileId = result.id;
        alert('Файл сохранён в Drive: ' + currentFileId);
        listFiles();
      } catch (error) {
        console.error('Ошибка создания файла', error);
      }
    }

    async function updateFileOnDrive(fileId) {
      try {
        const contentHtml = document.querySelector('.canvas').outerHTML;
        const contentBlob = new Blob([contentHtml], { type: 'text/html' });
        const metadata = {
          name: 'drawing.html',
          mimeType: 'text/html',
          parents: driveFolderId ? [driveFolderId] : [] // используем существующую папку, если есть
        };
        const form = new FormData();
        form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
        form.append('file', contentBlob);
        await fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=multipart`, {
          method: 'PATCH',
          headers: { Authorization: `Bearer ${accessToken}` },
          body: form
        });
        alert('Файл обновлён в Drive');
        listFiles();
      } catch (error) {
        console.error('Ошибка обновления файла', error);
      }
    }
    document.getElementById("driveSave").addEventListener("click", saveToDrive);
    document.getElementById("driveOpen").addEventListener("click", listFiles);
  </script>

  <!-- Основной скрипт для рисования и редактирования -->
  <script>
    "use strict";
    // Sign in/out
    document.getElementById('signin_button').onclick = handleSignInClick;
    document.getElementById('signout_button').onclick = handleSignOutClick;

    const canvas = document.querySelector(".canvas");
    const snapToGridCheckbox = document.getElementById("snapToGrid");
    const shapeIcons = document.querySelectorAll(".icon");
    const layersList = document.getElementById("layersList");
    const noLayersMsg = document.getElementById("noLayersMsg");
    const undoButton = document.getElementById("undo");
    const redoButton = document.getElementById("redo");
    const colorPanel = document.getElementById("colorPanel");
    const cpFillColor = document.getElementById("cpFillColor");
    const cpFillOpacity = document.getElementById("cpFillOpacity");
    const cpBorderColor = document.getElementById("cpBorderColor");
    const cpBorderOpacity = document.getElementById("cpBorderOpacity");
    const cpBorderWidth = document.getElementById("cpBorderWidth");
    const cpWidth = document.getElementById("cpWidth");
    const cpHeight = document.getElementById("cpHeight");
    const cpAngle = document.getElementById("cpAngle");
    const cpFontSize = document.getElementById("cpFontSize");
    const textSizeGroup = document.getElementById("textSizeGroup");
    const cpClose = document.getElementById("cpClose");

    // Zoom controls
    const zoomInBtn = document.getElementById("zoomIn");
    const zoomOutBtn = document.getElementById("zoomOut");
    const zoomResetBtn = document.getElementById("zoomReset");
    let canvasScale = 1;
    zoomInBtn.addEventListener("click", () => {
      canvasScale = Math.min(canvasScale + 0.1, 2);
      canvas.style.transform = `scale(${canvasScale})`;
    });
    zoomOutBtn.addEventListener("click", () => {
      canvasScale = Math.max(canvasScale - 0.1, 0.5);
      canvas.style.transform = `scale(${canvasScale})`;
    });
    zoomResetBtn.addEventListener("click", () => {
      canvasScale = 1;
      canvas.style.transform = `scale(1)`;
    });

    // По умолчанию выбран инструмент "rectangle"
    let selectedShapeType = "rectangle";
    shapeIcons.forEach(icon => {
      icon.classList.remove("active");
      if (icon.getAttribute("data-shape") === "rectangle") {
        icon.classList.add("active");
      }
    });

    const GRID_SIZE = 20;
    let shapes = [];
    let redoStack = [];
    let isDrawing = false;
    let startX = 0;
    let startY = 0;
    let currentShape = null;
    let selectedShape = null;

    // Выбор инструмента
    shapeIcons.forEach(icon => {
      icon.addEventListener("click", () => {
        shapeIcons.forEach(i => i.classList.remove("active"));
        icon.classList.add("active");
        selectedShapeType = icon.getAttribute("data-shape");
        if (selectedShapeType !== "pointer") hideColorPanel();
      });
    });

    /* Утилиты */
    function generateId() { return "shape-" + Math.random().toString(36).substr(2, 9); }
    function snap(value, gridSize) { return Math.round(value / gridSize) * gridSize; }
    function hexToRgb(hex) {
      const bigint = parseInt(hex.replace("#", ""), 16);
      return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
    }
    function rgbToHex(rgb) {
      if (!rgb) return "";
      const result = /^rgba?\((\d+),\s*(\d+),\s*(\d+)/i.exec(rgb);
      return result ? "#" +
          ("0" + parseInt(result[1], 10).toString(16)).slice(-2) +
          ("0" + parseInt(result[2], 10).toString(16)).slice(-2) +
          ("0" + parseInt(result[3], 10).toString(16)).slice(-2)
          : "";
    }
    function getCurrentRotation(el) {
      const st = window.getComputedStyle(el, null);
      const tr = st.getPropertyValue("transform");
      if (tr && tr !== "none") {
        const values = tr.split("(")[1].split(")")[0].split(",");
        const a = parseFloat(values[0]), b = parseFloat(values[1]);
        return Math.round(Math.atan2(b, a) * (180 / Math.PI));
      }
      return 0;
    }
    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return { x: (e.clientX - rect.left) / canvasScale, y: (e.clientY - rect.top) / canvasScale };
    }

    /* Слои */
    function renderLayers() {
      layersList.innerHTML = "";
      if (shapes.length === 0) { layersList.appendChild(noLayersMsg); return; }
      shapes.forEach((shape, index) => {
        const div = document.createElement("div");
        div.classList.add("layer-item");
        div.draggable = true;
        div.textContent = `${shape.type} (${shape.id})`;
        const delBtn = document.createElement("button");
        delBtn.classList.add("delete-layer-button");
        delBtn.textContent = "X";
        delBtn.title = "Удалить фигуру";
        delBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          shape.element.remove();
          shapes = shapes.filter(s => s.id !== shape.id);
          if (selectedShape && selectedShape.id === shape.id) { selectedShape = null; hideColorPanel(); }
          renderLayers();
        });
        div.appendChild(delBtn);
        if (selectedShape && selectedShape.id === shape.id) { div.classList.add("selected"); }
        div.addEventListener("click", () => selectShape(shape));
        div.addEventListener("dragstart", e => { e.dataTransfer.setData("text/plain", String(index)); });
        div.addEventListener("dragover", e => e.preventDefault());
        div.addEventListener("drop", e => {
          e.preventDefault();
          const fromIndex = parseInt(e.dataTransfer.getData("text/plain"), 10);
          const toIndex = index;
          if (fromIndex !== toIndex) { const moved = shapes.splice(fromIndex, 1)[0]; shapes.splice(toIndex, 0, moved); reassignZIndices(); }
        });
        layersList.appendChild(div);
      });
    }
    function reassignZIndices() {
      shapes.forEach((s, i) => { s.zIndex = i + 1; s.element.style.zIndex = s.zIndex; });
      renderLayers();
    }
    function selectShape(shapeObj) {
      selectedShape = shapeObj;
      updateSelectionUI();
      showColorPanel(shapeObj);
    }
    function updateSelectionUI() {
      shapes.forEach(s => s.element.classList.remove("selected"));
      if (selectedShape) { selectedShape.element.classList.add("selected"); }
      renderLayers();
    }

    /* Панель управления объектом – появляется над выделённым объектом */
    function showColorPanel(shapeObj) {
      const compStyle = window.getComputedStyle(shapeObj.element);
      // Fill
      const bg = compStyle.backgroundColor;
      const fillMatch = bg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
      if (fillMatch) {
        cpFillColor.value = rgbToHex(`rgb(${fillMatch[1]},${fillMatch[2]},${fillMatch[3]})`);
        cpFillOpacity.value = fillMatch[4] ? parseFloat(fillMatch[4]) : 1;
      } else { cpFillColor.value = "#ff0000"; cpFillOpacity.value = "1"; }
      // Border
      const bc = compStyle.borderColor;
      const borderMatch = bc.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
      if (borderMatch) {
        cpBorderColor.value = rgbToHex(`rgb(${borderMatch[1]},${borderMatch[2]},${borderMatch[3]})`);
        cpBorderOpacity.value = borderMatch[4] ? parseFloat(borderMatch[4]) : 1;
      } else { cpBorderColor.value = "#000000"; cpBorderOpacity.value = "1"; }
      cpBorderWidth.value = parseInt(compStyle.borderWidth) || 1;
      cpWidth.value = parseInt(compStyle.width) || 0;
      cpHeight.value = parseInt(compStyle.height) || 0;
      cpAngle.value = getCurrentRotation(shapeObj.element);
      if (shapeObj.type === "text") {
        textSizeGroup.style.display = "flex";
        cpFontSize.value = parseInt(window.getComputedStyle(shapeObj.element).fontSize) || 16;
      } else {
        textSizeGroup.style.display = "none";
      }
      const rect = shapeObj.element.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      let top = rect.top - canvasRect.top - colorPanel.offsetHeight - 6;
      if (top < 0) top = rect.bottom - canvasRect.top + 6;
      colorPanel.style.left = (rect.left - canvasRect.left + 4) + "px";
      colorPanel.style.top = top + "px";
      colorPanel.style.display = "flex";
    }
    function hideColorPanel() { colorPanel.style.display = "none"; }
    cpFillColor.addEventListener("input", updateShapeStyle);
    cpFillOpacity.addEventListener("input", updateShapeStyle);
    cpBorderColor.addEventListener("input", updateShapeStyle);
    cpBorderOpacity.addEventListener("input", updateShapeStyle);
    cpBorderWidth.addEventListener("input", updateShapeStyle);
    cpWidth.addEventListener("input", () => { if (selectedShape) { selectedShape.element.style.width = cpWidth.value + "px"; showColorPanel(selectedShape); } });
    cpHeight.addEventListener("input", () => { if (selectedShape) { selectedShape.element.style.height = cpHeight.value + "px"; showColorPanel(selectedShape); } });
    cpAngle.addEventListener("input", () => { if (selectedShape) { let angle = parseFloat(cpAngle.value) || 0; selectedShape.element.style.transform = `rotate(${angle}deg)`; showColorPanel(selectedShape); } });
    cpFontSize.addEventListener("input", () => { if (selectedShape && selectedShape.type === "text") { selectedShape.element.style.fontSize = cpFontSize.value + "px"; } });
    cpClose.addEventListener("click", hideColorPanel);
    function updateShapeStyle() {
      if (!selectedShape) return;
      const fillRgb = hexToRgb(cpFillColor.value);
      const fillOp = parseFloat(cpFillOpacity.value);
      selectedShape.element.style.backgroundColor = `rgba(${fillRgb.r},${fillRgb.g},${fillRgb.b},${fillOp})`;
      const borderRgb = hexToRgb(cpBorderColor.value);
      const borderOp = parseFloat(cpBorderOpacity.value);
      selectedShape.element.style.borderColor = `rgba(${borderRgb.r},${borderRgb.g},${borderRgb.b},${borderOp})`;
      selectedShape.element.style.borderWidth = cpBorderWidth.value + "px";
    }

    /* Создание фигур */
    function createArrow(e) {
      const pos = getMousePos(e);
      const id = generateId();
      const arrowContainer = document.createElement("div");
      arrowContainer.classList.add("arrow-container");
      arrowContainer.dataset.id = id;
      arrowContainer.style.left = pos.x + "px";
      arrowContainer.style.top = pos.y + "px";
      arrowContainer.style.zIndex = shapes.length + 1;
      arrowContainer.addEventListener("mousedown", e => {
        e.stopPropagation();
        selectedShape = shapes.find(s => s.id === id);
        updateSelectionUI();
        showColorPanel(selectedShape);
      });
      const bw = parseInt(cpBorderWidth.value) || 1;
      const bRgb = hexToRgb(cpBorderColor.value);
      const bOp = parseFloat(cpBorderOpacity.value) || 1;
      const borderColor = `rgba(${bRgb.r},${bRgb.g},${bRgb.b},${bOp})`;
      const arrowShaft = document.createElement("div");
      arrowShaft.classList.add("arrow-shaft");
      arrowShaft.style.height = bw + "px";
      arrowShaft.style.backgroundColor = borderColor;
      const arrowHead = document.createElement("div");
      arrowHead.classList.add("arrow-head");
      arrowHead.style.borderLeft = "10px solid " + borderColor;
      const startHandle = document.createElement("div");
      startHandle.classList.add("arrow-handle");
      const endHandle = document.createElement("div");
      endHandle.classList.add("arrow-handle");
      arrowContainer.appendChild(arrowShaft);
      arrowContainer.appendChild(arrowHead);
      arrowContainer.appendChild(startHandle);
      arrowContainer.appendChild(endHandle);
      canvas.appendChild(arrowContainer);
      const arrowObj = {
        id,
        element: arrowContainer,
        shaft: arrowShaft,
        head: arrowHead,
        type: "arrow",
        zIndex: shapes.length + 1,
        startX: pos.x, startY: pos.y,
        endX: pos.x, endY: pos.y,
        startHandle, endHandle
      };
      shapes.push(arrowObj);
      selectShape(arrowObj);
      addArrowHandleEvents(arrowObj);
      function mouseMove(ev) {
        const pos2 = getMousePos(ev);
        arrowObj.endX = pos2.x;
        arrowObj.endY = pos2.y;
        updateArrowUI(arrowObj);
      }
      function mouseUp() {
        document.removeEventListener("mousemove", mouseMove);
        document.removeEventListener("mouseup", mouseUp);
      }
      document.addEventListener("mousemove", mouseMove);
      document.addEventListener("mouseup", mouseUp);
    }
    function updateArrowUI(arrowObj) {
      const { startX, startY, endX, endY, element, shaft, head, startHandle, endHandle } = arrowObj;
      const dx = endX - startX, dy = endY - startY;
      const length = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx) * (180 / Math.PI);
      element.style.left = startX + "px";
      element.style.top = startY + "px";
      element.style.transformOrigin = "0 0";
      element.style.transform = `rotate(${angle}deg)`;
      shaft.style.width = length + "px";
      head.style.left = (length - 10) + "px";
      head.style.top = "50%";
      head.style.transform = "translateY(-50%)";
      startHandle.style.left = "0px";
      startHandle.style.top = "50%";
      endHandle.style.left = length + "px";
      endHandle.style.top = "50%";
    }
    function addArrowHandleEvents(arrowObj) {
      const { startHandle, endHandle } = arrowObj;
      startHandle.addEventListener("mousedown", e => {
        e.stopPropagation();
        const rect = canvas.getBoundingClientRect();
        function onMouseMove(ev) {
          const pos = { x: (ev.clientX - rect.left) / canvasScale, y: (ev.clientY - rect.top) / canvasScale };
          arrowObj.startX = snapToGridCheckbox.checked ? snap(pos.x, GRID_SIZE) : pos.x;
          arrowObj.startY = snapToGridCheckbox.checked ? snap(pos.y, GRID_SIZE) : pos.y;
          updateArrowUI(arrowObj);
        }
        function onMouseUp() {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        }
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      });
      endHandle.addEventListener("mousedown", e => {
        e.stopPropagation();
        const rect = canvas.getBoundingClientRect();
        function onMouseMove(ev) {
          const pos = { x: (ev.clientX - rect.left) / canvasScale, y: (ev.clientY - rect.top) / canvasScale };
          arrowObj.endX = snapToGridCheckbox.checked ? snap(pos.x, GRID_SIZE) : pos.x;
          arrowObj.endY = snapToGridCheckbox.checked ? snap(pos.y, GRID_SIZE) : pos.y;
          updateArrowUI(arrowObj);
        }
        function onMouseUp() {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        }
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      });
    }
    function createTextShape(e) {
      const pos = getMousePos(e);
      const id = generateId();
      const el = document.createElement("div");
      el.classList.add("shape", "shape-text");
      el.dataset.id = id;
      el.style.left = pos.x + "px";
      el.style.top = pos.y + "px";
      el.style.border = "1px solid var(--color-border)";
      el.style.backgroundColor = "#fff";
      el.contentEditable = "true";
      el.innerText = "";
      canvas.appendChild(el);
      setTimeout(() => { el.focus(); }, 0);
      const shapeObj = { id, element: el, type: "text", zIndex: shapes.length + 1 };
      shapes.push(shapeObj);
      addShapeEventListeners(el);
      selectShape(shapeObj);
      showColorPanel(shapeObj);
      addResizeHandle(el);
      addRotateHandle(el);
    }
    function createRectOrCircle() {
      const id = generateId();
      const el = document.createElement("div");
      el.classList.add("shape");
      if (selectedShapeType === "circle") el.classList.add("circle");
      el.dataset.id = id;
      const fillRgb = hexToRgb(cpFillColor.value) || { r: 0, g: 0, b: 0 };
      const fillOp = parseFloat(cpFillOpacity.value) || 1;
      el.style.backgroundColor = `rgba(${fillRgb.r},${fillRgb.g},${fillRgb.b},${fillOp})`;
      const borderRgb = hexToRgb(cpBorderColor.value) || { r: 0, g: 0, b: 0 };
      const borderOp = parseFloat(cpBorderOpacity.value) || 1;
      const borderW = parseInt(cpBorderWidth.value) || 1;
      el.style.borderWidth = borderW + "px";
      el.style.borderColor = `rgba(${borderRgb.r},${borderRgb.g},${borderRgb.b},${borderOp})`;
      canvas.appendChild(el);
      const shapeObj = { id, element: el, type: selectedShapeType, zIndex: shapes.length + 1 };
      shapes.push(shapeObj);
      addShapeEventListeners(el);
      selectShape(shapeObj);
      showColorPanel(shapeObj);
      return shapeObj;
    }
    /* События фигур */
    function addShapeEventListeners(el) {
      el.addEventListener("mousedown", e => {
        if (isDrawing) return;
        e.stopPropagation();
        selectedShape = shapes.find(s => s.id === el.dataset.id);
        updateSelectionUI();
        showColorPanel(selectedShape);
        if (selectedShape.type === "arrow") return;
        const offsetX = e.offsetX;
        const offsetY = e.offsetY;
        function mouseMove(ev) {
          const pos = getMousePos(ev);
          let left = pos.x - offsetX;
          let top = pos.y - offsetY;
          if (snapToGridCheckbox.checked) {
            left = snap(left, GRID_SIZE);
            top = snap(top, GRID_SIZE);
          }
          selectedShape.element.style.left = left + "px";
          selectedShape.element.style.top = top + "px";
          showColorPanel(selectedShape);
        }
        function mouseUp() {
          document.removeEventListener("mousemove", mouseMove);
          document.removeEventListener("mouseup", mouseUp);
        }
        document.addEventListener("mousemove", mouseMove);
        document.addEventListener("mouseup", mouseUp);
      });
    }
    /* Рисование */
    canvas.addEventListener("mousedown", e => {
      if (selectedShapeType === "pointer") return;
      if (selectedShapeType === "arrow") { createArrow(e); return; }
      if (selectedShapeType === "text") { createTextShape(e); return; }
      isDrawing = true;
      const pos = getMousePos(e);
      startX = pos.x; startY = pos.y;
      currentShape = createRectOrCircle();
      currentShape.element.style.left = startX + "px";
      currentShape.element.style.top = startY + "px";
      currentShape.element.style.width = "0px";
      currentShape.element.style.height = "0px";
    });
    canvas.addEventListener("mousemove", e => {
      if (!isDrawing || !currentShape) return;
      const pos = getMousePos(e);
      let left = Math.min(startX, pos.x);
      let top = Math.min(startY, pos.y);
      let width = Math.abs(pos.x - startX);
      let height = Math.abs(pos.y - startY);
      if (snapToGridCheckbox.checked) {
        left = snap(left, GRID_SIZE);
        top = snap(top, GRID_SIZE);
        width = snap(width, GRID_SIZE);
        height = snap(height, GRID_SIZE);
      }
      currentShape.element.style.left = left + "px";
      currentShape.element.style.top = top + "px";
      currentShape.element.style.width = width + "px";
      currentShape.element.style.height = height + "px";
      if (currentShape.type === "circle") { currentShape.element.style.borderRadius = "50%"; }
      showColorPanel(currentShape);
    });
    canvas.addEventListener("mouseup", () => {
      if (!isDrawing) return;
      isDrawing = false;
      if (currentShape) {
        addResizeHandle(currentShape.element);
        addRotateHandle(currentShape.element);
        currentShape = null;
      }
      reassignZIndices();
    });
    canvas.addEventListener("mousedown", e => {
      if (e.target === canvas) {
        selectedShape = null;
        updateSelectionUI();
        hideColorPanel();
      }
    });
    /* Resize / Rotate ручки */
    function addResizeHandle(el) {
      if (el.querySelector(".resize-handle")) return;
      const resize = document.createElement("div");
      resize.classList.add("resize-handle");
      el.appendChild(resize);
      resize.addEventListener("mousedown", e => {
        e.stopPropagation();
        const initX = e.clientX, initY = e.clientY;
        const initW = parseInt(el.style.width), initH = parseInt(el.style.height);
        const left = parseInt(el.style.left), top = parseInt(el.style.top);
        function onMouseMove(ev) {
          const dx = ev.clientX - initX, dy = ev.clientY - initY;
          let newW = initW + dx, newH = initH + dy;
          if (newW < 0) { el.style.left = (left + newW) + "px"; newW = Math.abs(newW); }
          if (newH < 0) { el.style.top = (top + newH) + "px"; newH = Math.abs(newH); }
          if (ev.shiftKey) {
            const ratio = initW / initH || 1;
            if (Math.abs(dx) > Math.abs(dy)) { newH = newW / ratio; }
            else { newW = newH * ratio; }
          }
          if (snapToGridCheckbox.checked) {
            newW = snap(newW, GRID_SIZE);
            newH = snap(newH, GRID_SIZE);
          }
          el.style.width = newW + "px";
          el.style.height = newH + "px";
          const s = shapes.find(s => s.element === el);
          if (s) { cpWidth.value = newW; cpHeight.value = newH; }
          showColorPanel(shapes.find(s => s.element === el));
        }
        function onMouseUp() {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        }
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      });
    }
    function addRotateHandle(el) {
      if (el.querySelector(".rotate-handle")) return;
      const rotate = document.createElement("div");
      rotate.classList.add("rotate-handle");
      el.appendChild(rotate);
      rotate.addEventListener("mousedown", e => {
        e.stopPropagation();
        const rect = canvas.getBoundingClientRect();
        const centerX = el.offsetLeft + el.offsetWidth/2;
        const centerY = el.offsetTop + el.offsetHeight/2;
        function onMouseMove(ev) {
          const mouseX = (ev.clientX - rect.left) / canvasScale;
          const mouseY = (ev.clientY - rect.top) / canvasScale;
          const dx = mouseX - centerX, dy = mouseY - centerY;
          let angle = Math.atan2(dy, dx) * (180/Math.PI);
          el.style.transform = `rotate(${angle}deg)`;
          showColorPanel(shapes.find(s => s.element === el));
        }
        function onMouseUp() {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        }
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      });
    }
    /* Undo / Redo */
    undoButton.addEventListener("click", () => {
      if (shapes.length > 0) {
        const last = shapes.pop();
        redoStack.push(last);
        last.element.remove();
        if (selectedShape && selectedShape.id === last.id) { selectedShape = null; hideColorPanel(); }
        renderLayers();
      }
    });
    redoButton.addEventListener("click", () => {
      if (redoStack.length > 0) {
        const shapeObj = redoStack.pop();
        shapes.push(shapeObj);
        canvas.appendChild(shapeObj.element);
        if (shapeObj.type === "arrow") { addArrowHandleEvents(shapeObj); updateArrowUI(shapeObj); }
        reassignZIndices();
      }
    });
  </script>
</body>
</html>
