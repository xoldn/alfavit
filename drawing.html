<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Drawing App Pro - Final Edition</title>
  <!-- Google Identity Services -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <style>
    :root {
      /* Современная цветовая палитра */
      --color-bg: #f9fafc;
      --color-sidebar: #ffffff;
      --color-panel: #ffffff;
      --color-border: #d8dee4;
      --color-text: #24292f;
      --color-primary: #2563eb;
      --color-secondary: #10b981;
      --color-accent: #f97316;
      --color-danger: #ef4444;
      --font-family: "Inter", sans-serif;
      --transition-speed: 0.2s;
      --sidebar-width: 320px;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
    }
    body {
      display: flex;
      background: var(--color-bg);
      font-family: var(--font-family);
      color: var(--color-text);
    }
    /* ----------------- Левая панель ----------------- */
    .sidebar {
      flex: 0 0 var(--sidebar-width);
      background: var(--color-sidebar);
      border-right: 1px solid var(--color-border);
      display: flex;
      flex-direction: column;
      padding: 16px;
      gap: 20px;
      box-shadow: 2px 0 5px rgba(0,0,0,0.05);
    }
    /* Заголовок инструментов и версия */
    .sidebar-header {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .sidebar-header h2 {
      font-size: 1.2rem;
      color: var(--color-primary);
    }
    .version {
      font-size: 0.85rem;
      color: #999;
    }
    /* Панель инструментов (иконки) */
    .toolbar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .icon {
      width: 48px;
      height: 48px;
      background: #fff;
      border: 2px solid var(--color-border);
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: transform var(--transition-speed), background var(--transition-speed), border-color var(--transition-speed);
      user-select: none;
    }
    .icon:hover {
      background: var(--color-primary);
      border-color: var(--color-primary);
      transform: scale(1.07);
    }
    .icon.active {
      background: var(--color-accent);
      border-color: var(--color-accent);
      transform: scale(1.07);
    }
    .icon svg {
      width: 24px;
      height: 24px;
      fill: var(--color-text);
      transition: fill var(--transition-speed);
    }
    .icon:hover svg, .icon.active svg {
      fill: #fff;
    }
    /* Секция «Слои» – заголовок и кнопки Undo/Redo */
    .layers-header {
      font-size: 1.2rem;
      color: var(--color-primary);
      margin-bottom: 4px;
    }
    .layer-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }
    .btn-undo-redo {
      width: 48px;
      height: 48px;
      background: #fff;
      border: 2px solid var(--color-border);
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: transform var(--transition-speed), background var(--transition-speed), border-color var(--transition-speed);
    }
    .btn-undo-redo:hover {
      background: var(--color-primary);
      border-color: var(--color-primary);
      transform: scale(1.07);
    }
    .btn-undo-redo svg {
      width: 24px;
      height: 24px;
      fill: var(--color-text);
      transition: fill var(--transition-speed);
    }
    .btn-undo-redo:hover svg {
      fill: #fff;
    }
    /* Список слоёв */
    .layers {
      flex: 1;
      border: 1px solid var(--color-border);
      border-radius: 6px;
      padding: 8px;
      background: #fff;
      overflow-y: auto;
    }
    .layer-item {
      display: flex;
      align-items: center;
      border-radius: 6px;
      background: #f3f4f6;
      margin-bottom: 6px;
      padding: 8px;
      cursor: move;
      transition: background var(--transition-speed), transform var(--transition-speed);
    }
    .layer-item:hover {
      background: #e2e3e5;
      transform: scale(1.02);
    }
    .layer-item.selected {
      background: var(--color-accent);
      color: #fff;
    }
    .delete-layer-button {
      margin-left: auto;
      background: var(--color-danger);
      border: none;
      border-radius: 6px;
      padding: 4px 8px;
      color: #fff;
      cursor: pointer;
      transition: background var(--transition-speed);
    }
    .delete-layer-button:hover {
      background: #b91c1c;
    }
    #noLayersMsg {
      color: #666;
      text-align: center;
      margin: 6px 0;
    }
    /* ----------------- Холст ----------------- */
    .canvas-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 16px;
      background: var(--color-bg);
      overflow: auto;
      position: relative;
    }
    .canvas {
      width: 900px;
      height: 600px;
      background: #fff;
      border: 1px solid var(--color-border);
      border-radius: 8px;
      position: relative;
      box-shadow: 0 3px 12px rgba(0,0,0,0.08);
    }
    /* Фигуры */
    .shape {
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      border-style: solid;
      transform-origin: center;
      box-sizing: border-box;
      transition: box-shadow var(--transition-speed);
    }
    .shape:hover {
      box-shadow: 0 0 4px rgba(0,0,0,0.15);
    }
    .circle {
      border-radius: 50%;
    }
    .shape-text {
      min-width: 30px;
      min-height: 20px;
      white-space: pre-wrap;
      word-break: break-word;
      outline: none;
      cursor: text;
    }
    .selected {
      outline: 2px dashed var(--color-secondary);
      outline-offset: 2px;
    }
    /* Ручки resize/rotate */
    .resize-handle,
    .rotate-handle {
      display: none;
    }
    .selected .resize-handle,
    .selected .rotate-handle {
      display: block;
    }
    .resize-handle, .rotate-handle {
      background: var(--color-primary);
      border-radius: 50%;
      width: 12px;
      height: 12px;
    }
    .resize-handle {
      position: absolute;
      right: -6px;
      bottom: -6px;
      cursor: nwse-resize;
    }
    .rotate-handle {
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      cursor: grab;
    }
    /* Панель управления (однострочная) */
    .color-panel {
      position: absolute;
      background: var(--color-panel);
      border: 1px solid var(--color-border);
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      padding: 4px 8px;
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.85rem;
    }
    .color-panel label {
      margin-right: 4px;
      white-space: nowrap;
      color: #555;
    }
    .color-panel input[type="color"],
    .color-panel input[type="range"],
    .color-panel input[type="number"] {
      max-width: 70px;
    }
    .color-panel button {
      background: var(--color-accent);
      border: none;
      color: #fff;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
      transition: background var(--transition-speed);
    }
    .color-panel button:hover {
      background: var(--color-primary);
    }
    /* Стрелка и её ручки */
    .arrow-container {
      position: absolute;
      pointer-events: auto;
    }
    .arrow-shaft {
      position: absolute;
      top: 50%;
      left: 0;
      height: 2px;
      transform: translateY(-50%);
    }
    .arrow-head {
      position: absolute;
      width: 0;
      height: 0;
      border-top: 5px solid transparent;
      border-bottom: 5px solid transparent;
      transform: translateY(-50%);
    }
    .arrow-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      background: var(--color-primary);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      cursor: move;
      display: none;
    }
    .arrow-container.selected .arrow-handle {
      display: block;
    }
  </style>
</head>
<body>
  <!-- Левая панель -->
  <div class="sidebar">
    <div class="sidebar-header">
      <h2>Инструменты</h2>
      <div class="version">Version Final.1.0</div>
    </div>
    <div class="toolbar">
      <div class="icon pointer active" data-shape="pointer" title="Указатель">
        <svg viewBox="0 0 16 16">
          <path d="M2 2v12l4-4 3 4 2-2-3-4 4-4H2z"/>
        </svg>
      </div>
      <div class="icon rectangle" data-shape="rectangle" title="Прямоугольник">
        <svg viewBox="0 0 16 16">
          <rect x="3" y="3" width="10" height="10" rx="1" ry="1"/>
        </svg>
      </div>
      <div class="icon circle" data-shape="circle" title="Круг">
        <svg viewBox="0 0 16 16">
          <circle cx="8" cy="8" r="5"/>
        </svg>
      </div>
      <div class="icon arrow" data-shape="arrow" title="Стрелка">
        <svg viewBox="0 0 16 16">
          <path d="M2 8h9l-3.5-3.5L9 3l5 5-5 5-1.5-1.5L11 8H2z"/>
        </svg>
      </div>
      <div class="icon text" data-shape="text" title="Текст">
        <svg viewBox="0 0 16 16">
          <text x="3" y="12" font-size="10" font-family="Arial" fill="currentColor">T</text>
        </svg>
      </div>
    </div>
    <div>
      <label>
        <input type="checkbox" id="snapToGrid" />
        Привязка к сетке
      </label>
    </div>
    <div class="sidebar-header">
      <h2>Слои</h2>
    </div>
    <!-- Кнопки Undo/Redo под заголовком "Слои" -->
    <div class="layer-controls">
      <div id="undo" class="btn-undo-redo" title="Отменить (Undo)">
        <svg viewBox="0 0 24 24">
          <path d="M12.5 8c-2.14 0-3.86 1.72-3.86 3.86v.76L6 10v6h6l-2.64-2.64v-.5A1.86 1.86 0 0112.5 12c.86 0 1.64.56 1.84 1.4.12.5.62.8 1.14.8.08 0 .16-.01.24-.03.62-.17 1.02-.8.85-1.42A3.86 3.86 0 0012.5 8z"/>
        </svg>
      </div>
      <div id="redo" class="btn-undo-redo" title="Повторить (Redo)">
        <svg viewBox="0 0 24 24">
          <path d="M13.64 7.36A3.86 3.86 0 0010.5 6c-2.14 0-3.86 1.72-3.86 3.86 0 .62.23 1.25.68 1.84.28.38.21.93-.17 1.22-.38.28-.93.21-1.22-.17A5.78 5.78 0 014.78 9.86 5.86 5.86 0 0110.5 4c2.23 0 4.15 1.3 5.06 3.16l1.44-1.44V12h-6l2.64-2.64z"/>
        </svg>
      </div>
    </div>
    <div class="layers" id="layersList">
      <p id="noLayersMsg">Нет слоёв</p>
    </div>
    <div id="driveControls" class="form-group">
      <label>Интеграция с Google Drive</label>
      <button id="signin_button">Войти</button>
      <button id="signout_button" style="display:none;">Выйти</button>
      <div id="driveFileList"></div>
    </div>
  </div>

  <!-- Холст -->
  <div class="canvas-container">
    <div class="canvas"></div>
    <!-- Панель управления (однострочная) -->
    <div id="colorPanel" class="color-panel">
      <label>Fill:</label>
      <input type="color" id="cpFillColor" value="#ff0000" />
      <label>Op:</label>
      <input type="range" id="cpFillOpacity" min="0" max="1" step="0.1" value="1" />
      <label>Border:</label>
      <input type="color" id="cpBorderColor" value="#000000" />
      <label>Op:</label>
      <input type="range" id="cpBorderOpacity" min="0" max="1" step="0.1" value="1" />
      <label>BW:</label>
      <input type="number" id="cpBorderWidth" min="0" max="20" value="1" />
      <label>W:</label>
      <input type="number" id="cpWidth" min="0" max="2000" value="100" />
      <label>H:</label>
      <input type="number" id="cpHeight" min="0" max="2000" value="100" />
      <button id="cpClose">Close</button>
    </div>
  </div>

  <!-- Скрипты Google Drive (без изменений) -->
  <script>
    "use strict";
    const CLIENT_ID = "158627123477-4m4d7dqms8ndlmfq4mejhdguj1jte08m.apps.googleusercontent.com";
    const SCOPES = "https://www.googleapis.com/auth/drive.file";
    let accessToken = null;
    let tokenClient = null;
    let currentFileId = null;
    window.onload = () => {
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPES,
        callback: (tokenResponse) => {
          accessToken = tokenResponse.access_token;
          console.log("Access token получен:", accessToken);
          listFiles();
        },
      });
    };
    function handleSignInClick() {
      tokenClient.requestAccessToken({ prompt: "" });
    }
    function handleSignOutClick() {
      if (accessToken) {
        fetch("https://oauth2.googleapis.com/revoke?token=" + accessToken, {
          method: "POST",
          headers: { "Content-type": "application/x-www-form-urlencoded" }
        })
          .then(() => console.log("Token revoked"))
          .catch(err => console.error(err));
      }
      accessToken = null;
      currentFileId = null;
      document.getElementById('driveFileList').innerHTML = '';
      document.getElementById('signin_button').style.display = 'block';
      document.getElementById('signout_button').style.display = 'none';
    }
    async function listFiles() {
      if (!accessToken) {
        console.warn("Нет access token. Сначала войдите.");
        return;
      }
      try {
        const resp = await fetch("https://www.googleapis.com/drive/v3/files?pageSize=10&q=mimeType!='application/vnd.google-apps.folder'", {
          headers: { Authorization: `Bearer ${accessToken}` }
        });
        const data = await resp.json();
        const fileListElem = document.getElementById('driveFileList');
        fileListElem.innerHTML = '';
        if (data.files && data.files.length > 0) {
          data.files.forEach(file => {
            const div = document.createElement('div');
            div.classList.add('drive-file');
            div.textContent = `${file.name} (${file.id})`;
            div.addEventListener('click', () => loadFromDrive(file.id));
            fileListElem.appendChild(div);
          });
        } else {
          fileListElem.innerHTML = 'Файлы не найдены.';
        }
        document.getElementById('signin_button').style.display = 'none';
        document.getElementById('signout_button').style.display = 'block';
      } catch (err) {
        console.error("Ошибка при получении списка файлов", err);
      }
    }
    async function loadFromDrive(fileId) {
      if (!accessToken) {
        alert("Нет access token");
        return;
      }
      try {
        const resp = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
          headers: { Authorization: `Bearer ${accessToken}` }
        });
        const fileContent = await resp.text();
        document.querySelector('.canvas-container').innerHTML = fileContent;
        currentFileId = fileId;
        alert('Файл загружен из Drive.');
      } catch (error) {
        console.error('Ошибка загрузки файла', error);
      }
    }
    async function saveToDrive() {
      if (!accessToken) {
        console.warn("Нет access token для сохранения.");
        return;
      }
      if (!currentFileId) {
        await createFileOnDrive();
      } else {
        await updateFileOnDrive(currentFileId);
      }
    }
    async function createFileOnDrive() {
      try {
        const contentHtml = document.querySelector('.canvas').outerHTML;
        const contentBlob = new Blob([contentHtml], { type: 'text/html' });
        const metadata = { name: 'drawing.html', mimeType: 'text/html' };
        const form = new FormData();
        form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
        form.append('file', contentBlob);
        const resp = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
          method: 'POST',
          headers: { Authorization: `Bearer ${accessToken}` },
          body: form
        });
        const result = await resp.json();
        currentFileId = result.id;
        alert('Файл создан в Drive: ' + currentFileId);
      } catch (error) {
        console.error('Ошибка создания файла', error);
      }
    }
    async function updateFileOnDrive(fileId) {
      try {
        const contentHtml = document.querySelector('.canvas').outerHTML;
        const contentBlob = new Blob([contentHtml], { type: 'text/html' });
        const metadata = { name: 'drawing.html', mimeType: 'text/html' };
        const form = new FormData();
        form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
        form.append('file', contentBlob);
        await fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=multipart`, {
          method: 'PATCH',
          headers: { Authorization: `Bearer ${accessToken}` },
          body: form
        });
      } catch (error) {
        console.error('Ошибка обновления файла', error);
      }
    }
  </script>

  <!-- Основной скрипт для рисования и редактирования фигур -->
  <script>
    "use strict";
    const canvas = document.querySelector(".canvas");
    const snapToGridCheckbox = document.getElementById("snapToGrid");
    const shapeIcons = document.querySelectorAll(".icon");

    const layersList = document.getElementById("layersList");
    const noLayersMsg = document.getElementById("noLayersMsg");

    const undoButton = document.getElementById("undo");
    const redoButton = document.getElementById("redo");

    const colorPanel = document.getElementById("colorPanel");
    const cpFillColor = document.getElementById("cpFillColor");
    const cpFillOpacity = document.getElementById("cpFillOpacity");
    const cpBorderColor = document.getElementById("cpBorderColor");
    const cpBorderOpacity = document.getElementById("cpBorderOpacity");
    const cpBorderWidth = document.getElementById("cpBorderWidth");
    const cpWidth = document.getElementById("cpWidth");
    const cpHeight = document.getElementById("cpHeight");
    const cpClose = document.getElementById("cpClose");

    const GRID_SIZE = 20;
    let selectedShapeType = "pointer";
    let shapes = [];
    let redoStack = [];
    let isDrawing = false;
    let startX = 0;
    let startY = 0;
    let currentShape = null;
    let selectedShape = null;

    /* Выбор инструмента */
    shapeIcons.forEach(icon => {
      icon.addEventListener("click", () => {
        shapeIcons.forEach(i => i.classList.remove("active"));
        icon.classList.add("active");
        selectedShapeType = icon.getAttribute("data-shape");
        if (selectedShapeType !== "pointer") hideColorPanel();
      });
    });

    /* Утилиты */
    function generateId() {
      return 'shape-' + Math.random().toString(36).substr(2, 9);
    }
    function snap(value, gridSize) {
      return Math.round(value / gridSize) * gridSize;
    }
    function hexToRgb(hex) {
      const bigint = parseInt(hex.replace("#", ""), 16);
      return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255
      };
    }
    function rgbToHex(rgb) {
      if (!rgb) return "";
      const result = /^rgba?\((\d+),\s*(\d+),\s*(\d+)/i.exec(rgb);
      return result
        ? "#" +
          ("0" + parseInt(result[1], 10).toString(16)).slice(-2) +
          ("0" + parseInt(result[2], 10).toString(16)).slice(-2) +
          ("0" + parseInt(result[3], 10).toString(16)).slice(-2)
        : "";
    }
    function getCurrentRotation(el) {
      const st = window.getComputedStyle(el, null);
      const tr = st.getPropertyValue("transform");
      if (tr && tr !== "none") {
        const values = tr.split("(")[1].split(")")[0].split(",");
        const a = parseFloat(values[0]);
        const b = parseFloat(values[1]);
        const angle = Math.round(Math.atan2(b, a) * (180 / Math.PI));
        return angle;
      }
      return 0;
    }

    /* Слои */
    function renderLayers() {
      layersList.innerHTML = "";
      if (shapes.length === 0) {
        layersList.appendChild(noLayersMsg);
        return;
      }
      shapes.forEach((shape, index) => {
        const div = document.createElement("div");
        div.classList.add("layer-item");
        div.draggable = true;
        div.textContent = `${shape.type} (${shape.id})`;
        const delBtn = document.createElement("button");
        delBtn.classList.add("delete-layer-button");
        delBtn.textContent = "X";
        delBtn.title = "Удалить фигуру";
        delBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          shape.element.remove();
          shapes = shapes.filter(s => s.id !== shape.id);
          if (selectedShape && selectedShape.id === shape.id) {
            selectedShape = null;
            hideColorPanel();
          }
          renderLayers();
        });
        div.appendChild(delBtn);
        if (selectedShape && selectedShape.id === shape.id) {
          div.classList.add("selected");
        }
        div.addEventListener("click", () => selectShape(shape));
        div.addEventListener("dragstart", e => {
          e.dataTransfer.setData("text/plain", String(index));
        });
        div.addEventListener("dragover", e => e.preventDefault());
        div.addEventListener("drop", e => {
          e.preventDefault();
          const fromIndex = parseInt(e.dataTransfer.getData("text/plain"), 10);
          const toIndex = index;
          if (fromIndex !== toIndex) {
            const moved = shapes.splice(fromIndex, 1)[0];
            shapes.splice(toIndex, 0, moved);
            reassignZIndices();
          }
        });
        layersList.appendChild(div);
      });
    }
    function reassignZIndices() {
      shapes.forEach((s, i) => {
        s.zIndex = i + 1;
        s.element.style.zIndex = s.zIndex;
      });
      renderLayers();
    }
    function selectShape(shapeObj) {
      selectedShape = shapeObj;
      updateSelectionUI();
      showColorPanel(shapeObj);
    }
    function updateSelectionUI() {
      shapes.forEach(s => s.element.classList.remove("selected"));
      if (selectedShape) {
        selectedShape.element.classList.add("selected");
      }
      renderLayers();
    }

    /* Панель свойств – теперь однострочная и над фигурой */
    function showColorPanel(shapeObj) {
      const compStyle = window.getComputedStyle(shapeObj.element);
      // Fill
      const bg = compStyle.backgroundColor;
      const fillMatch = bg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
      if (fillMatch) {
        cpFillColor.value = rgbToHex(`rgb(${fillMatch[1]},${fillMatch[2]},${fillMatch[3]})`);
        cpFillOpacity.value = fillMatch[4] ? parseFloat(fillMatch[4]) : 1;
      } else {
        cpFillColor.value = "#ff0000";
        cpFillOpacity.value = "1";
      }
      // Border
      const bc = compStyle.borderColor;
      const borderMatch = bc.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
      if (borderMatch) {
        cpBorderColor.value = rgbToHex(`rgb(${borderMatch[1]},${borderMatch[2]},${borderMatch[3]})`);
        cpBorderOpacity.value = borderMatch[4] ? parseFloat(borderMatch[4]) : 1;
      } else {
        cpBorderColor.value = "#000000";
        cpBorderOpacity.value = "1";
      }
      cpBorderWidth.value = parseInt(compStyle.borderWidth) || 1;
      // Размеры (ширина и высота)
      cpWidth.value = parseInt(compStyle.width) || 0;
      cpHeight.value = parseInt(compStyle.height) || 0;
      // Позиция: выше фигуры
      const rect = shapeObj.element.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      let top = rect.top - canvasRect.top - colorPanel.offsetHeight - 6;
      if (top < 0) { top = rect.bottom - canvasRect.top + 6; }
      colorPanel.style.left = (rect.left - canvasRect.left + 4) + "px";
      colorPanel.style.top = top + "px";
      colorPanel.style.display = "flex";
    }
    function hideColorPanel() {
      colorPanel.style.display = "none";
    }
    cpFillColor.addEventListener("input", updateShapeStyle);
    cpFillOpacity.addEventListener("input", updateShapeStyle);
    cpBorderColor.addEventListener("input", updateShapeStyle);
    cpBorderOpacity.addEventListener("input", updateShapeStyle);
    cpBorderWidth.addEventListener("input", updateShapeStyle);
    cpWidth.addEventListener("input", () => {
      if (selectedShape) {
        selectedShape.element.style.width = cpWidth.value + "px";
        showColorPanel(selectedShape);
      }
    });
    cpHeight.addEventListener("input", () => {
      if (selectedShape) {
        selectedShape.element.style.height = cpHeight.value + "px";
        showColorPanel(selectedShape);
      }
    });
    cpClose.addEventListener("click", hideColorPanel);
    function updateShapeStyle() {
      if (!selectedShape) return;
      const fillRgb = hexToRgb(cpFillColor.value);
      const fillOp = parseFloat(cpFillOpacity.value);
      selectedShape.element.style.backgroundColor = `rgba(${fillRgb.r},${fillRgb.g},${fillRgb.b},${fillOp})`;
      const borderRgb = hexToRgb(cpBorderColor.value);
      const borderOp = parseFloat(cpBorderOpacity.value);
      selectedShape.element.style.borderColor = `rgba(${borderRgb.r},${borderRgb.g},${borderRgb.b},${borderOp})`;
      selectedShape.element.style.borderWidth = cpBorderWidth.value + "px";
    }

    /* Создание фигур */
    function createArrow(e) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const id = generateId();
      const arrowContainer = document.createElement("div");
      arrowContainer.classList.add("arrow-container");
      arrowContainer.dataset.id = id;
      arrowContainer.style.left = x + "px";
      arrowContainer.style.top = y + "px";
      arrowContainer.style.zIndex = shapes.length + 1;
      // Стержень
      const arrowShaft = document.createElement("div");
      arrowShaft.classList.add("arrow-shaft");
      const bw = parseInt(cpBorderWidth.value) || 1;
      arrowShaft.style.height = bw + "px";
      const bRgb = hexToRgb(cpBorderColor.value);
      const bOp = parseFloat(cpBorderOpacity.value) || 1;
      const borderColor = `rgba(${bRgb.r},${bRgb.g},${bRgb.b},${bOp})`;
      arrowShaft.style.backgroundColor = borderColor;
      // Наконечник
      const arrowHead = document.createElement("div");
      arrowHead.classList.add("arrow-head");
      arrowHead.style.borderLeft = "10px solid " + borderColor;
      // Ручки для редактирования
      const startHandle = document.createElement("div");
      startHandle.classList.add("arrow-handle");
      const endHandle = document.createElement("div");
      endHandle.classList.add("arrow-handle");
      arrowContainer.appendChild(arrowShaft);
      arrowContainer.appendChild(arrowHead);
      arrowContainer.appendChild(startHandle);
      arrowContainer.appendChild(endHandle);
      canvas.appendChild(arrowContainer);
      const arrowObj = {
        id,
        element: arrowContainer,
        shaft: arrowShaft,
        head: arrowHead,
        type: "arrow",
        zIndex: shapes.length + 1,
        startX: x, startY: y,
        endX: x, endY: y,
        startHandle, endHandle
      };
      shapes.push(arrowObj);
      selectShape(arrowObj);
      addArrowHandleEvents(arrowObj);
      function mouseMove(ev) {
        const nx = ev.clientX - rect.left;
        const ny = ev.clientY - rect.top;
        arrowObj.endX = nx;
        arrowObj.endY = ny;
        updateArrowUI(arrowObj);
      }
      function mouseUp() {
        document.removeEventListener("mousemove", mouseMove);
        document.removeEventListener("mouseup", mouseUp);
      }
      document.addEventListener("mousemove", mouseMove);
      document.addEventListener("mouseup", mouseUp);
    }
    function updateArrowUI(arrowObj) {
      const { startX, startY, endX, endY, element, shaft, head, startHandle, endHandle } = arrowObj;
      const dx = endX - startX;
      const dy = endY - startY;
      const length = Math.sqrt(dx * dx + dy * dy);
      // Поворот
      const angle = Math.atan2(dy, dx) * (180 / Math.PI);
      // Устанавливаем положение контейнера в точке начала
      element.style.left = startX + "px";
      element.style.top = startY + "px";
      element.style.transformOrigin = "0 0";
      element.style.transform = `rotate(${angle}deg)`;
      shaft.style.width = length + "px";
      head.style.left = (length - 10) + "px";
      head.style.top = "50%";
      head.style.transform = "translateY(-50%)";
      // Ручки
      startHandle.style.left = "0px";
      startHandle.style.top = "50%";
      endHandle.style.left = length + "px";
      endHandle.style.top = "50%";
    }
    function addArrowHandleEvents(arrowObj) {
      const { startHandle, endHandle } = arrowObj;
      startHandle.addEventListener("mousedown", e => {
        e.stopPropagation();
        const rect = canvas.getBoundingClientRect();
        function onMouseMove(ev) {
          arrowObj.startX = snapToGridCheckbox.checked ? snap(ev.clientX - rect.left, GRID_SIZE) : ev.clientX - rect.left;
          arrowObj.startY = snapToGridCheckbox.checked ? snap(ev.clientY - rect.top, GRID_SIZE) : ev.clientY - rect.top;
          updateArrowUI(arrowObj);
        }
        function onMouseUp() {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        }
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      });
      endHandle.addEventListener("mousedown", e => {
        e.stopPropagation();
        const rect = canvas.getBoundingClientRect();
        function onMouseMove(ev) {
          arrowObj.endX = snapToGridCheckbox.checked ? snap(ev.clientX - rect.left, GRID_SIZE) : ev.clientX - rect.left;
          arrowObj.endY = snapToGridCheckbox.checked ? snap(ev.clientY - rect.top, GRID_SIZE) : ev.clientY - rect.top;
          updateArrowUI(arrowObj);
        }
        function onMouseUp() {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        }
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      });
    }
    function createTextShape(e) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const id = generateId();
      const el = document.createElement("div");
      el.classList.add("shape", "shape-text");
      el.dataset.id = id;
      el.style.left = x + "px";
      el.style.top = y + "px";
      el.style.border = "none";
      el.contentEditable = "true";
      el.innerText = "";
      canvas.appendChild(el);
      // Сразу фокус для редактирования (многострочный текст)
      setTimeout(() => { el.focus(); }, 0);
      const shapeObj = { id, element: el, type: "text", zIndex: shapes.length + 1 };
      shapes.push(shapeObj);
      addShapeEventListeners(el);
      selectShape(shapeObj);
      showColorPanel(shapeObj);
      addResizeHandle(el);
      addRotateHandle(el);
    }
    function createRectOrCircle() {
      const id = generateId();
      const el = document.createElement("div");
      el.classList.add("shape");
      if (selectedShapeType === "circle") el.classList.add("circle");
      el.dataset.id = id;
      const fillRgb = hexToRgb(cpFillColor.value) || { r: 0, g: 0, b: 0 };
      const fillOp = parseFloat(cpFillOpacity.value) || 1;
      el.style.backgroundColor = `rgba(${fillRgb.r},${fillRgb.g},${fillRgb.b},${fillOp})`;
      const borderRgb = hexToRgb(cpBorderColor.value) || { r: 0, g: 0, b: 0 };
      const borderOp = parseFloat(cpBorderOpacity.value) || 1;
      const borderW = parseInt(cpBorderWidth.value) || 1;
      el.style.borderWidth = borderW + "px";
      el.style.borderColor = `rgba(${borderRgb.r},${borderRgb.g},${borderRgb.b},${borderOp})`;
      canvas.appendChild(el);
      const shapeObj = { id, element: el, type: selectedShapeType, zIndex: shapes.length + 1 };
      shapes.push(shapeObj);
      addShapeEventListeners(el);
      selectShape(shapeObj);
      showColorPanel(shapeObj);
      return shapeObj;
    }
    /* События фигур */
    function addShapeEventListeners(el) {
      el.addEventListener("mousedown", e => {
        if (isDrawing) return;
        e.stopPropagation();
        selectedShape = shapes.find(s => s.id === el.dataset.id);
        updateSelectionUI();
        showColorPanel(selectedShape);
        if (selectedShape.type === "arrow") return;
        const offsetX = e.offsetX;
        const offsetY = e.offsetY;
        function mouseMove(ev) {
          const rect = canvas.getBoundingClientRect();
          let left = ev.clientX - rect.left - offsetX;
          let top = ev.clientY - rect.top - offsetY;
          if (snapToGridCheckbox.checked) {
            left = snap(left, GRID_SIZE);
            top = snap(top, GRID_SIZE);
          }
          selectedShape.element.style.left = left + "px";
          selectedShape.element.style.top = top + "px";
          showColorPanel(selectedShape);
        }
        function mouseUp() {
          document.removeEventListener("mousemove", mouseMove);
          document.removeEventListener("mouseup", mouseUp);
        }
        document.addEventListener("mousemove", mouseMove);
        document.addEventListener("mouseup", mouseUp);
      });
    }
    /* Рисование */
    canvas.addEventListener("mousedown", e => {
      if (selectedShapeType === "pointer") return;
      if (selectedShapeType === "arrow") {
        createArrow(e);
        return;
      }
      if (selectedShapeType === "text") {
        createTextShape(e);
        return;
      }
      isDrawing = true;
      const rect = canvas.getBoundingClientRect();
      startX = e.clientX - rect.left;
      startY = e.clientY - rect.top;
      currentShape = createRectOrCircle();
      currentShape.element.style.left = startX + "px";
      currentShape.element.style.top = startY + "px";
      currentShape.element.style.width = "0px";
      currentShape.element.style.height = "0px";
    });
    canvas.addEventListener("mousemove", e => {
      if (!isDrawing || !currentShape) return;
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      let left = Math.min(startX, mouseX);
      let top = Math.min(startY, mouseY);
      let width = Math.abs(mouseX - startX);
      let height = Math.abs(mouseY - startY);
      if (snapToGridCheckbox.checked) {
        left = snap(left, GRID_SIZE);
        top = snap(top, GRID_SIZE);
        width = snap(width, GRID_SIZE);
        height = snap(height, GRID_SIZE);
      }
      currentShape.element.style.left = left + "px";
      currentShape.element.style.top = top + "px";
      currentShape.element.style.width = width + "px";
      currentShape.element.style.height = height + "px";
      if (currentShape.type === "circle") {
        currentShape.element.style.borderRadius = "50%";
      }
      showColorPanel(currentShape);
    });
    canvas.addEventListener("mouseup", () => {
      if (!isDrawing) return;
      isDrawing = false;
      if (currentShape) {
        addResizeHandle(currentShape.element);
        addRotateHandle(currentShape.element);
        currentShape = null;
      }
      reassignZIndices();
    });
    canvas.addEventListener("mousedown", e => {
      if (e.target === canvas) {
        selectedShape = null;
        updateSelectionUI();
        hideColorPanel();
      }
    });
    /* Resize / Rotate ручки */
    function addResizeHandle(el) {
      if (el.querySelector(".resize-handle")) return;
      const resize = document.createElement("div");
      resize.classList.add("resize-handle");
      el.appendChild(resize);
      resize.addEventListener("mousedown", e => {
        e.stopPropagation();
        const initX = e.clientX;
        const initY = e.clientY;
        const initW = parseInt(el.style.width);
        const initH = parseInt(el.style.height);
        const left = parseInt(el.style.left);
        const top = parseInt(el.style.top);
        function mouseMove(ev) {
          const dx = ev.clientX - initX;
          const dy = ev.clientY - initY;
          let newW = initW + dx;
          let newH = initH + dy;
          if (newW < 0) {
            el.style.left = (left + newW) + "px";
            newW = Math.abs(newW);
          }
          if (newH < 0) {
            el.style.top = (top + newH) + "px";
            newH = Math.abs(newH);
          }
          if (ev.shiftKey) {
            const ratio = initW / initH || 1;
            if (Math.abs(dx) > Math.abs(dy)) {
              newH = newW / ratio;
            } else {
              newW = newH * ratio;
            }
          }
          if (snapToGridCheckbox.checked) {
            newW = snap(newW, GRID_SIZE);
            newH = snap(newH, GRID_SIZE);
          }
          el.style.width = newW + "px";
          el.style.height = newH + "px";
          // Обновляем размеры в панели
          const s = shapes.find(s => s.element === el);
          if (s) {
            cpWidth.value = newW;
            cpHeight.value = newH;
          }
          showColorPanel(shapes.find(s => s.element === el));
        }
        function onMouseUp() {
          document.removeEventListener("mousemove", mouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        }
        document.addEventListener("mousemove", mouseMove);
        document.addEventListener("mouseup", onMouseUp);
      });
    }
    function addRotateHandle(el) {
      if (el.querySelector(".rotate-handle")) return;
      const rotate = document.createElement("div");
      rotate.classList.add("rotate-handle");
      el.appendChild(rotate);
      rotate.addEventListener("mousedown", e => {
        e.stopPropagation();
        const rect = canvas.getBoundingClientRect();
        const centerX = el.offsetLeft + el.offsetWidth/2;
        const centerY = el.offsetTop + el.offsetHeight/2;
        const startAngle = getCurrentRotation(el);
        function onMouseMove(ev) {
          const mouseX = ev.clientX - rect.left;
          const mouseY = ev.clientY - rect.top;
          const dx = mouseX - centerX;
          const dy = mouseY - centerY;
          let angle = Math.atan2(dy, dx) * (180/Math.PI);
          el.style.transform = `rotate(${angle}deg)`;
          showColorPanel(shapes.find(s=>s.element===el));
        }
        function onMouseUp() {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        }
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      });
    }
    /* Undo / Redo */
    undoButton.addEventListener("click", () => {
      if (shapes.length > 0) {
        const last = shapes.pop();
        redoStack.push(last);
        last.element.remove();
        if (selectedShape && selectedShape.id === last.id) {
          selectedShape = null;
          hideColorPanel();
        }
        renderLayers();
      }
    });
    redoButton.addEventListener("click", () => {
      if (redoStack.length > 0) {
        const shapeObj = redoStack.pop();
        shapes.push(shapeObj);
        canvas.appendChild(shapeObj.element);
        if (shapeObj.type === "arrow") {
          addArrowHandleEvents(shapeObj);
          updateArrowUI(shapeObj);
        }
        reassignZIndices();
      }
    });
  </script>
</body>
</html>
