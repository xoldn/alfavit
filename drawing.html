<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Drawing App Pro - GIS Version</title>

  <!-- Google Identity Services -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: Arial, sans-serif;
      background-color: #f2f2f2;
      display: flex;
      flex-direction: row;
      height: 100vh;
    }
    .sidebar {
      width: 300px;
      background-color: #ffffff;
      border-right: 1px solid #ccc;
      display: flex;
      flex-direction: column;
      padding: 16px;
      overflow-y: auto;
    }
    .sidebar h2 {
      margin-top: 0;
      margin-bottom: 10px;
    }
    .form-group {
      margin-bottom: 10px;
      display: flex;
      flex-direction: column;
    }
    .form-group label {
      margin-bottom: 4px;
      font-weight: bold;
      font-size: 14px;
    }

    /* Highlight the active tool in the toolbar */
    .icon {
      width: 40px;
      height: 40px;
      border: 2px solid #666;
      cursor: pointer;
      border-radius: 4px;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      transition: border-color 0.2s;
    }
    .icon.active {
      border-color: #f00;
    }

    .icon.rectangle::before {
      content: "";
      width: 60%;
      height: 40%;
      background: #ccc;
      display: block;
    }
    .icon.circle::before {
      content: "";
      width: 50%;
      height: 50%;
      background: #ccc;
      border-radius: 50%;
      display: block;
    }
    .icon.text::before {
      content: "T";
      font-weight: bold;
      color: #666;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 16px;
    }

    .canvas-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    .canvas {
      width: 900px;
      height: 600px;
      border: 1px solid #999;
      background-color: #fff;
      position: relative;
    }

    .shape {
      position: absolute;
      border-style: solid;
      display: flex;
      justify-content: center;
      align-items: center;
      box-sizing: border-box;
      transform-origin: center center;
      padding: 4px;
    }
    .shape.locked {
      pointer-events: none;
      opacity: 0.5;
    }
    .circle {
      border-radius: 50%;
    }
    .shape-text {
      min-width: 30px;
      min-height: 20px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .resize-handle {
      width: 10px;
      height: 10px;
      background: #333;
      position: absolute;
      right: -5px;
      bottom: -5px;
      cursor: nwse-resize;
    }
    .rotate-handle {
      width: 10px;
      height: 10px;
      background: #333;
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      cursor: grab;
      border-radius: 50%;
    }

    .selected {
      outline: 2px dashed blue;
    }

    .layers {
      flex: 1;
      overflow-y: auto;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 8px;
      margin-bottom: 10px;
    }
    .layer-item {
      padding: 4px 8px;
      margin: 4px 0;
      background: #eee;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .layer-item.selected {
      background: #d0ebff;
      outline: 1px solid #409eff;
    }
    .layer-controls {
      display: flex;
      gap: 4px;
    }
    .layer-btn {
      background: #ccc;
      border: none;
      padding: 2px 4px;
      cursor: pointer;
      border-radius: 4px;
    }
    .layer-btn:hover {
      background: #bbb;
    }

    #deleteShape {
      background: #f44336;
      color: white;
      border: none;
      padding: 6px 12px;
      cursor: pointer;
      border-radius: 4px;
      margin-bottom: 10px;
      transition: background 0.2s;
    }
    #deleteShape:hover {
      background: #e03128;
    }
  </style>
</head>
<body>
  <div class="sidebar">
    <h2>Tools</h2>
    <div class="toolbar">
      <div class="icon rectangle active" data-shape="rectangle" title="Rectangle"></div>
      <div class="icon circle" data-shape="circle" title="Circle"></div>
      <div class="icon text" data-shape="text" title="Text"></div>
    </div>
    <div class="form-group">
      <label for="colorPicker">Fill Color</label>
      <input type="color" id="colorPicker" value="#ff0000" />
    </div>
    <div class="form-group">
      <label for="fillOpacityRange">Fill Opacity</label>
      <input type="range" id="fillOpacityRange" min="0" max="1" step="0.1" value="1" />
    </div>
    <div class="form-group">
      <label for="borderColorPicker">Border Color</label>
      <input type="color" id="borderColorPicker" value="#000000" />
    </div>
    <div class="form-group">
      <label for="borderOpacityRange">Border Opacity</label>
      <input type="range" id="borderOpacityRange" min="0" max="1" step="0.1" value="1" />
    </div>
    <div class="form-group">
      <label for="borderWidth">Border Width</label>
      <input type="number" id="borderWidth" min="0" max="20" value="1" />
    </div>
    <div class="form-group">
      <label><input type="checkbox" id="snapToGrid" /> Snap to Grid</label>
    </div>
    <div class="form-group group-btn">
      <button id="groupShapes">Group</button>
      <button id="ungroupShapes">Ungroup</button>
    </div>
    <div class="form-group">
      <button id="undo">Undo</button>
      <button id="redo">Redo</button>
    </div>
    <div class="form-group">
      <button id="export">Export</button>
    </div>
    <button id="deleteShape">Delete Shape</button>

    <h3>Layers</h3>
    <div class="layers" id="layersList"></div>

    <!-- Drive Controls -->
    <div class="form-group" id="driveControls">
      <label>Google Drive Integration</label>
      <button id="signin_button">Sign In</button>
      <button id="signout_button" style="display:none">Sign Out</button>
      <div id="driveFileList"></div>
    </div>
  </div>

  <div class="canvas-container">
    <div class="canvas"></div>
  </div>

  <script>
    // =======================
    // Google Identity Services (New)
    // =======================

    const CLIENT_ID = "158627123477-4m4d7dqms8ndlmfq4mejhdguj1jte08m.apps.googleusercontent.com";
    const SCOPES = "https://www.googleapis.com/auth/drive.file";

    let accessToken = null;
    let tokenClient = null;
    let currentFileId = null;

    window.onload = () => {
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPES,
        callback: (tokenResponse) => {
          accessToken = tokenResponse.access_token;
          console.log("Got access token", accessToken);
          listFiles();
        },
      });
    };

    function handleSignInClick() {
      tokenClient.requestAccessToken({ prompt: "" });
    }

    function handleSignOutClick() {
      if (accessToken) {
        fetch("https://oauth2.googleapis.com/revoke?token=" + accessToken, {
          method: "POST",
          headers: { "Content-type": "application/x-www-form-urlencoded" }
        })
          .then(() => {
            console.log("Token revoked");
          })
          .catch(err => console.error(err));
      }
      accessToken = null;
      currentFileId = null;
      document.getElementById('driveFileList').innerHTML = '';
      document.getElementById('signin_button').style.display = 'block';
      document.getElementById('signout_button').style.display = 'none';
    }

    async function listFiles() {
      if (!accessToken) {
        console.warn("No access token. Sign in first.");
        return;
      }
      try {
        const resp = await fetch("https://www.googleapis.com/drive/v3/files?pageSize=10&q=mimeType!='application/vnd.google-apps.folder'", {
          headers: {
            Authorization: `Bearer ${accessToken}`
          }
        });
        const data = await resp.json();
        const fileListElem = document.getElementById('driveFileList');
        fileListElem.innerHTML = '';
        if (data.files && data.files.length > 0) {
          data.files.forEach(file => {
            const div = document.createElement('div');
            div.classList.add('drive-file');
            div.textContent = file.name + ' (' + file.id + ')';
            div.addEventListener('click', () => {
              loadFromDrive(file.id);
            });
            fileListElem.appendChild(div);
          });
        } else {
          fileListElem.innerHTML = 'No files found.';
        }
        document.getElementById('signin_button').style.display = 'none';
        document.getElementById('signout_button').style.display = 'block';
      } catch (err) {
        console.error("Error listing files", err);
      }
    }

    async function loadFromDrive(fileId) {
      if (!accessToken) {
        alert("No access token");
        return;
      }
      try {
        const resp = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
          headers: {
            Authorization: `Bearer ${accessToken}`
          }
        });
        const fileContent = await resp.text();
        document.querySelector('.canvas-container').innerHTML = fileContent;
        currentFileId = fileId;
        alert('File loaded from Drive.');
        // Re-init shape events if needed.
      } catch (error) {
        console.error('Error loading file', error);
      }
    }

    async function saveToDrive() {
      if (!accessToken) {
        console.warn("No access token to save.");
        return;
      }
      if (!currentFileId) {
        await createFileOnDrive();
      } else {
        await updateFileOnDrive(currentFileId);
      }
    }

    async function createFileOnDrive() {
      try {
        const contentHtml = document.querySelector('.canvas').outerHTML;
        const contentBlob = new Blob([contentHtml], { type: 'text/html' });
        const metadata = {
          name: 'drawing.html',
          mimeType: 'text/html'
        };
        const form = new FormData();
        form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
        form.append('file', contentBlob);

        const resp = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${accessToken}`
          },
          body: form
        });
        const result = await resp.json();
        currentFileId = result.id;
        alert('File created on Drive: ' + currentFileId);
      } catch (error) {
        console.error('Error creating file', error);
      }
    }

    async function updateFileOnDrive(fileId) {
      try {
        const contentHtml = document.querySelector('.canvas').outerHTML;
        const contentBlob = new Blob([contentHtml], { type: 'text/html' });
        const metadata = {
          name: 'drawing.html',
          mimeType: 'text/html'
        };

        const form = new FormData();
        form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
        form.append('file', contentBlob);

        // remove confirmation alert
        await fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=multipart`, {
          method: 'PATCH',
          headers: {
            'Authorization': `Bearer ${accessToken}`
          },
          body: form
        });
        // no alert here
      } catch (error) {
        console.error('Error updating file', error);
      }
    }
  </script>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      // Sign in/out
      document.getElementById('signin_button').onclick = handleSignInClick;
      document.getElementById('signout_button').onclick = handleSignOutClick;

      // UI references
      const canvas = document.querySelector(".canvas");
      const layersList = document.querySelector("#layersList");

      const colorPicker = document.querySelector("#colorPicker");
      const fillOpacityRange = document.querySelector("#fillOpacityRange");
      const borderColorPicker = document.querySelector("#borderColorPicker");
      const borderOpacityRange = document.querySelector("#borderOpacityRange");
      const borderWidthInput = document.querySelector("#borderWidth");
      const snapToGridCheckbox = document.querySelector("#snapToGrid");

      const groupBtn = document.querySelector("#groupShapes");
      const ungroupBtn = document.querySelector("#ungroupShapes");
      const undoButton = document.querySelector("#undo");
      const redoButton = document.querySelector("#redo");
      const exportButton = document.querySelector("#export");
      const shapeIcons = document.querySelectorAll(".icon");
      const deleteButton = document.querySelector("#deleteShape");

      let selectedShapeType = "rectangle";
      let shapes = [];
      let redoStack = [];
      let isDrawing = false;
      let startX = 0;
      let startY = 0;
      let currentShape = null;

      // We'll store fill + border separately, not using shapeEl.style.opacity.
      let selectedFillColor = "#ff0000";
      let selectedFillOpacity = 1;
      let selectedBorderColor = "#000000";
      let selectedBorderOpacity = 1;
      let selectedBorderWidth = 1;

      let selectedShapes = new Set();

      // auto-save every 5s if token
      setInterval(() => {
        if (accessToken) {
          saveToDrive();
        }
      }, 5000);

      function generateId() {
        return "id-" + Math.random().toString(36).substr(2, 9);
      }

      function safeParseFloat(val, def = 1) {
        const parsed = parseFloat(val);
        return isNaN(parsed) ? def : parsed;
      }

      function hexToRgb(hex) {
        hex = hex.replace(/^#/, "");
        if (hex.length === 3) {
          const r = parseInt(hex[0] + hex[0], 16);
          const g = parseInt(hex[1] + hex[1], 16);
          const b = parseInt(hex[2] + hex[2], 16);
          return { r, g, b };
        } else if (hex.length === 6) {
          const r = parseInt(hex.substring(0, 2), 16);
          const g = parseInt(hex.substring(2, 4), 16);
          const b = parseInt(hex.substring(4, 6), 16);
          return { r, g, b };
        }
        return null;
      }

      function snap(value, gridSize) {
        return Math.round(value / gridSize) * gridSize;
      }

      // Tools: highlight selected
      shapeIcons.forEach(icon => {
        icon.addEventListener("click", () => {
          shapeIcons.forEach(i => i.classList.remove("active"));
          icon.classList.add("active");
          selectedShapeType = icon.getAttribute("data-shape");
        });
      });

      /******************************************************/
      /* LAYERS + RENDER                                    */
      /******************************************************/
      function renderLayers() {
        layersList.innerHTML = "";
        const sorted = [...shapes].sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));
        sorted.forEach(shape => {
          const div = document.createElement("div");
          div.classList.add("layer-item");
          if (selectedShapes.has(shape.id)) {
            div.classList.add("selected");
          }
          div.textContent = `${shape.type} (${shape.id})`;

          const controls = document.createElement("div");
          controls.classList.add("layer-controls");
          const upBtn = document.createElement("button");
          upBtn.classList.add("layer-btn");
          upBtn.textContent = "▲";
          upBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            bringForward(shape.id);
          });
          const downBtn = document.createElement("button");
          downBtn.classList.add("layer-btn");
          downBtn.textContent = "▼";
          downBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            sendBackward(shape.id);
          });
          controls.appendChild(upBtn);
          controls.appendChild(downBtn);
          div.appendChild(controls);

          div.addEventListener("click", (e) => {
            e.stopPropagation();
            if (!e.shiftKey) {
              selectedShapes.clear();
            }
            if (selectedShapes.has(shape.id)) {
              selectedShapes.delete(shape.id);
            } else {
              selectedShapes.add(shape.id);
            }
            updateSelectionUI();
            renderLayers();
          });
          layersList.appendChild(div);
        });
      }

      function updateSelectionUI() {
        shapes.forEach(s => s.element.classList.remove("selected"));
        shapes.forEach(s => {
          if (selectedShapes.has(s.id)) {
            s.element.classList.add("selected");
          }
        });
      }

      function bringForward(id) {
        const shapeObj = shapes.find(s => s.id === id);
        if (!shapeObj) return;
        shapeObj.zIndex++;
        reassignZIndices();
      }

      function sendBackward(id) {
        const shapeObj = shapes.find(s => s.id === id);
        if (!shapeObj) return;
        shapeObj.zIndex = Math.max(1, shapeObj.zIndex - 1);
        reassignZIndices();
      }

      function reassignZIndices() {
        shapes.sort((a, b) => (a.zIndex || 1) - (b.zIndex || 1));
        shapes.forEach((s, i) => {
          s.zIndex = i + 1;
          s.element.style.zIndex = s.zIndex;
        });
        renderLayers();
      }

      /******************************************************/
      /* CREATE & DRAWING                                   */
      /******************************************************/
      function createNewShape() {
        const id = generateId();
        const el = document.createElement("div");
        el.classList.add("shape");
        if (selectedShapeType === "circle") {
          el.classList.add("circle");
        }
        // Construct RGBA for fill & border
        const fillRgb = hexToRgb(selectedFillColor) || { r: 0, g: 0, b: 0};
        const borderRgb = hexToRgb(selectedBorderColor) || { r: 0, g: 0, b: 0};
        el.style.backgroundColor = `rgba(${fillRgb.r}, ${fillRgb.g}, ${fillRgb.b}, ${selectedFillOpacity})`;
        el.style.borderWidth = selectedBorderWidth + "px";
        el.style.borderColor = `rgba(${borderRgb.r}, ${borderRgb.g}, ${borderRgb.b}, ${selectedBorderOpacity})`;
        el.style.left = startX + "px";
        el.style.top = startY + "px";
        el.style.width = "0px";
        el.style.height = "0px";
        el.dataset.id = id;
        addShapeEventListeners(el);

        const shapeObj = {
          id,
          element: el,
          type: selectedShapeType,
          zIndex: shapes.length + 1,
        };
        shapes.push(shapeObj);
        el.style.zIndex = shapeObj.zIndex;
        return shapeObj;
      }

      function createTextShape(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const id = generateId();
        const el = document.createElement("div");
        el.classList.add("shape", "shape-text");
        el.style.left = x + "px";
        el.style.top = y + "px";
        const fillRgb = hexToRgb(selectedFillColor) || { r: 0, g: 0, b: 0};
        const borderRgb = hexToRgb(selectedBorderColor) || { r: 0, g: 0, b: 0};
        el.style.backgroundColor = `rgba(${fillRgb.r}, ${fillRgb.g}, ${fillRgb.b}, ${selectedFillOpacity})`;
        el.style.borderWidth = selectedBorderWidth + "px";
        el.style.borderColor = `rgba(${borderRgb.r}, ${borderRgb.g}, ${borderRgb.b}, ${selectedBorderOpacity})`;
        el.style.zIndex = shapes.length + 1;
        el.style.minWidth = "50px";
        el.style.minHeight = "20px";
        el.dataset.id = id;
        el.contentEditable = "true";
        el.innerText = "Your Text";
        addShapeEventListeners(el);
        canvas.appendChild(el);
        const shapeObj = {
          id,
          element: el,
          type: "text",
          zIndex: shapes.length + 1,
        };
        shapes.push(shapeObj);
        selectedShapes.clear();
        selectedShapes.add(id);
        updateSelectionUI();
        addResizeHandle(el);
        addRotateHandle(el);
        renderLayers();
      }

      function addShapeEventListeners(el) {
        el.addEventListener("mousedown", shapeMouseDown);
      }

      // DRAG
      function shapeMouseDown(e) {
        if (isDrawing) return;
        const shapeEl = e.currentTarget;
        const shapeId = shapeEl.dataset.id;
        e.stopPropagation();
        if (!e.shiftKey && !selectedShapes.has(shapeId)) {
          selectedShapes.clear();
        }
        if (!selectedShapes.has(shapeId)) {
          selectedShapes.add(shapeId);
        }
        updateSelectionUI();
        renderLayers();

        let offsetX = e.offsetX;
        let offsetY = e.offsetY;

        function mouseMove(ev) {
          const cRect = canvas.getBoundingClientRect();
          let left = ev.clientX - cRect.left - offsetX;
          let top = ev.clientY - cRect.top - offsetY;
          if (snapToGridCheckbox.checked) {
            left = snap(left, 20);
            top = snap(top, 20);
          }
          selectedShapes.forEach(sId => {
            const sObj = shapes.find(obj => obj.id === sId);
            if (!sObj) return;
            const dx = parseInt(sObj.element.style.left) - parseInt(shapeEl.style.left);
            const dy = parseInt(sObj.element.style.top) - parseInt(shapeEl.style.top);
            sObj.element.style.left = (left + dx) + "px";
            sObj.element.style.top = (top + dy) + "px";
          });
        }

        function mouseUp() {
          document.removeEventListener("mousemove", mouseMove);
          document.removeEventListener("mouseup", mouseUp);
        }

        document.addEventListener("mousemove", mouseMove);
        document.addEventListener("mouseup", mouseUp);
      }

      // RESIZE
      function addResizeHandle(shapeEl) {
        if (shapeEl.querySelector(".resize-handle")) return;
        const resize = document.createElement("div");
        resize.classList.add("resize-handle");
        shapeEl.appendChild(resize);

        resize.addEventListener("mousedown", e => {
          e.stopPropagation();
          let initialX = e.clientX;
          let initialY = e.clientY;
          let initialW = parseInt(shapeEl.style.width);
          let initialH = parseInt(shapeEl.style.height);
          let shapeLeft = parseInt(shapeEl.style.left);
          let shapeTop = parseInt(shapeEl.style.top);

          function onMouseMove(ev) {
            const deltaX = ev.clientX - initialX;
            const deltaY = ev.clientY - initialY;
            let newWidth = initialW + deltaX;
            let newHeight = initialH + deltaY;
            if (newWidth < 0) {
              shapeEl.style.left = (shapeLeft + newWidth) + "px";
              newWidth = Math.abs(newWidth);
            }
            if (newHeight < 0) {
              shapeEl.style.top = (shapeTop + newHeight) + "px";
              newHeight = Math.abs(newHeight);
            }
            if (ev.shiftKey) {
              const aspect = initialW / initialH || 1;
              if (Math.abs(deltaX) > Math.abs(deltaY)) {
                newHeight = newWidth / aspect;
              } else {
                newWidth = newHeight * aspect;
              }
            }
            if (snapToGridCheckbox.checked) {
              newWidth = snap(newWidth, 20);
              newHeight = snap(newHeight, 20);
            }
            shapeEl.style.width = newWidth + "px";
            shapeEl.style.height = newHeight + "px";
          }

          function onMouseUp() {
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", onMouseUp);
          }

          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", onMouseUp);
        });
      }

      // ROTATE
      function addRotateHandle(shapeEl) {
        if (shapeEl.querySelector(".rotate-handle")) return;
        const rotate = document.createElement("div");
        rotate.classList.add("rotate-handle");
        shapeEl.appendChild(rotate);

        rotate.addEventListener("mousedown", e => {
          e.stopPropagation();
          const rect = canvas.getBoundingClientRect();
          const centerX = shapeEl.offsetLeft + shapeEl.offsetWidth / 2;
          const centerY = shapeEl.offsetTop + shapeEl.offsetHeight / 2;

          function onMouseMove(ev) {
            const mouseX = ev.clientX - rect.left;
            const mouseY = ev.clientY - rect.top;
            const dx = mouseX - centerX;
            const dy = mouseY - centerY;
            let angle = Math.atan2(dy, dx) * (180 / Math.PI);
            shapeEl.style.transform = `translate(0,0) rotate(${angle}deg)`;
          }

          function onMouseUp() {
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", onMouseUp);
          }

          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", onMouseUp);
        });
      }

      // GROUP / UNGROUP
      groupBtn.addEventListener("click", () => {
        if (selectedShapes.size < 2) return;
        const groupId = generateId();
        const groupEl = document.createElement("div");
        groupEl.classList.add("shape");
        groupEl.dataset.id = groupId;
        groupEl.dataset.isGroup = "true";
        groupEl.style.position = "absolute";
        groupEl.style.border = "2px dashed #444";
        canvas.appendChild(groupEl);

        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        const groupedShapes = [];
        shapes.forEach(s => {
          if (selectedShapes.has(s.id)) {
            const el = s.element;
            const x = parseInt(el.style.left);
            const y = parseInt(el.style.top);
            const w = parseInt(el.style.width) || el.offsetWidth;
            const h = parseInt(el.style.height) || el.offsetHeight;
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x + w > maxX) maxX = x + w;
            if (y + h > maxY) maxY = y + h;
            groupedShapes.push(s);
          }
        });
        const groupWidth = maxX - minX;
        const groupHeight = maxY - minY;
        groupEl.style.left = `${minX}px`;
        groupEl.style.top = `${minY}px`;
        groupEl.style.width = `${groupWidth}px`;
        groupEl.style.height = `${groupHeight}px`;

        groupedShapes.forEach(s => {
          const el = s.element;
          const shapeLeft = parseInt(el.style.left) - minX;
          const shapeTop = parseInt(el.style.top) - minY;
          el.style.left = shapeLeft + "px";
          el.style.top = shapeTop + "px";
          groupEl.appendChild(el);
        });

        shapes = shapes.filter(s => !selectedShapes.has(s.id));
        const groupObj = {
          id: groupId,
          element: groupEl,
          type: "group",
          zIndex: shapes.length + 1,
        };
        shapes.push(groupObj);
        groupEl.style.zIndex = groupObj.zIndex;
        selectedShapes.clear();
        selectedShapes.add(groupId);
        updateSelectionUI();
        renderLayers();
      });

      ungroupBtn.addEventListener("click", () => {
        if (selectedShapes.size !== 1) return;
        const id = [...selectedShapes][0];
        const shapeObj = shapes.find(s => s.id === id);
        if (!shapeObj || shapeObj.type !== "group") return;
        const groupEl = shapeObj.element;
        while (groupEl.firstChild) {
          const child = groupEl.firstChild;
          if (child.classList && child.classList.contains("shape")) {
            const offsetLeft = parseInt(groupEl.style.left);
            const offsetTop = parseInt(groupEl.style.top);
            const childLeft = parseInt(child.style.left) + offsetLeft;
            const childTop = parseInt(child.style.top) + offsetTop;
            child.style.left = childLeft + "px";
            child.style.top = childTop + "px";
            canvas.appendChild(child);
            const childId = child.dataset.id;
            const cShape = shapes.find(x => x.id === childId);
            if (!cShape) {
              shapes.push({
                id: childId,
                element: child,
                type: child.classList.contains("circle") ? "circle" : child.classList.contains("shape-text") ? "text" : "rectangle",
                zIndex: shapes.length + 1,
              });
              child.style.zIndex = shapes.length;
            } else {
              cShape.zIndex = shapes.length + 1;
              child.style.zIndex = cShape.zIndex;
            }
          } else {
            groupEl.removeChild(child);
          }
        }
        shapes = shapes.filter(s => s.id !== id);
        groupEl.remove();
        selectedShapes.clear();
        renderLayers();
      });

      // UNDO / REDO
      undoButton.addEventListener("click", () => {
        if (shapes.length > 0) {
          const last = shapes.pop();
          redoStack.push(last);
          last.element.remove();
          if (selectedShapes.has(last.id)) {
            selectedShapes.delete(last.id);
          }
          renderLayers();
        }
      });

      redoButton.addEventListener("click", () => {
        if (redoStack.length > 0) {
          const shapeObj = redoStack.pop();
          shapes.push(shapeObj);
          canvas.appendChild(shapeObj.element);
          reassignZIndices();
        }
      });

      // EXPORT
      exportButton.addEventListener("click", () => {
        const data = `<html>\n<body>\n${canvas.outerHTML}\n</body>\n</html>`;
        const blob = new Blob([data], { type: "text/html" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "drawing.html";
        a.click();
      });

      // DELETE
      deleteButton.addEventListener("click", () => {
        if (selectedShapes.size < 1) return;
        selectedShapes.forEach(sId => {
          const shapeObj = shapes.find(s => s.id === sId);
          if (shapeObj) {
            shapeObj.element.remove();
            shapes = shapes.filter(s => s.id !== sId);
          }
        });
        selectedShapes.clear();
        renderLayers();
      });

      // COLOR + OPACITY CONTROLS
      colorPicker.addEventListener("input", e => {
        selectedFillColor = e.target.value;
        selectedShapes.forEach(sId => {
          const sObj = shapes.find(obj => obj.id === sId);
          if (sObj && sObj.type !== "group") {
            const rgb = hexToRgb(selectedFillColor) || { r:0, g:0, b:0};
            sObj.element.style.backgroundColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${selectedFillOpacity})`;
          }
        });
      });

      fillOpacityRange.addEventListener("input", e => {
        selectedFillOpacity = safeParseFloat(e.target.value, 1);
        selectedShapes.forEach(sId => {
          const sObj = shapes.find(obj => obj.id === sId);
          if (sObj && sObj.type !== "group") {
            const fillRgb = hexToRgb(selectedFillColor) || {r:0,g:0,b:0};
            sObj.element.style.backgroundColor = `rgba(${fillRgb.r}, ${fillRgb.g}, ${fillRgb.b}, ${selectedFillOpacity})`;
          }
        });
      });

      borderColorPicker.addEventListener("input", e => {
        selectedBorderColor = e.target.value;
        selectedShapes.forEach(sId => {
          const sObj = shapes.find(obj => obj.id === sId);
          if (sObj && sObj.type !== "group") {
            const rgb = hexToRgb(selectedBorderColor) || {r:0,g:0,b:0};
            sObj.element.style.borderColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${selectedBorderOpacity})`;
          }
        });
      });

      borderOpacityRange.addEventListener("input", e => {
        selectedBorderOpacity = safeParseFloat(e.target.value, 1);
        selectedShapes.forEach(sId => {
          const sObj = shapes.find(obj => obj.id === sId);
          if (sObj && sObj.type !== "group") {
            const rgb = hexToRgb(selectedBorderColor) || {r:0,g:0,b:0};
            sObj.element.style.borderColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${selectedBorderOpacity})`;
          }
        });
      });

      borderWidthInput.addEventListener("input", e => {
        selectedBorderWidth = parseInt(e.target.value);
        selectedShapes.forEach(sId => {
          const sObj = shapes.find(obj => obj.id === sId);
          if (sObj && sObj.type !== "group") {
            sObj.element.style.borderWidth = selectedBorderWidth + "px";
          }
        });
      });

      // DRAW
      const canvasRect = canvas.getBoundingClientRect();

      canvas.addEventListener("mousedown", e => {
        if (selectedShapeType === "text") {
          createTextShape(e);
          return;
        }
        const rect = canvas.getBoundingClientRect();
        startX = e.clientX - rect.left;
        startY = e.clientY - rect.top;
        isDrawing = true;
        currentShape = createNewShape();
        canvas.appendChild(currentShape.element);
        selectedShapes.clear();
        selectedShapes.add(currentShape.id);
        updateSelectionUI();
      });

      canvas.addEventListener("mousemove", e => {
        if (!isDrawing || !currentShape) return;
        const rect = canvas.getBoundingClientRect();
        let width = (e.clientX - rect.left) - parseInt(currentShape.element.style.left);
        let height = (e.clientY - rect.top) - parseInt(currentShape.element.style.top);
        if (snapToGridCheckbox.checked) {
          width = snap(width, 20);
          height = snap(height, 20);
        }
        currentShape.element.style.width = width + "px";
        currentShape.element.style.height = height + "px";
        if (currentShape.type === "circle") {
          currentShape.element.style.borderRadius = "50%";
        }
      });

      canvas.addEventListener("mouseup", e => {
        if (!isDrawing) return;
        isDrawing = false;
        if (currentShape) {
          const shapeLeft = parseInt(currentShape.element.style.left);
          const shapeTop = parseInt(currentShape.element.style.top);
          let shapeW = parseInt(currentShape.element.style.width);
          let shapeH = parseInt(currentShape.element.style.height);
          if (shapeW < 0) {
            currentShape.element.style.left = (shapeLeft + shapeW) + "px";
            currentShape.element.style.width = Math.abs(shapeW) + "px";
          }
          if (shapeH < 0) {
            currentShape.element.style.top = (shapeTop + shapeH) + "px";
            currentShape.element.style.height = Math.abs(shapeH) + "px";
          }
          addResizeHandle(currentShape.element);
          addRotateHandle(currentShape.element);
          currentShape = null;
        }
        reassignZIndices();
      });
    });
  </script>
</body>
</html>

