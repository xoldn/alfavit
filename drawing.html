<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Drawing App Pro</title>

  <!-- Google API Loader -->
  <script src="https://apis.google.com/js/api.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: Arial, sans-serif;
      background-color: #f2f2f2;
      display: flex;
      flex-direction: row;
      height: 100vh;
    }
    .sidebar {
      width: 300px;
      background-color: #ffffff;
      border-right: 1px solid #ccc;
      display: flex;
      flex-direction: column;
      padding: 16px;
      overflow-y: auto;
    }
    .sidebar h2 {
      margin-top: 0;
      margin-bottom: 10px;
    }
    .form-group {
      margin-bottom: 10px;
      display: flex;
      flex-direction: column;
    }
    .form-group label {
      margin-bottom: 4px;
      font-weight: bold;
      font-size: 14px;
    }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 16px;
    }
    .icon {
      width: 40px;
      height: 40px;
      border: 2px solid #666;
      cursor: pointer;
      border-radius: 4px;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
    }
    .icon.rectangle::before {
      content: "";
      width: 60%;
      height: 40%;
      background: #ccc;
      display: block;
    }
    .icon.circle::before {
      content: "";
      width: 50%;
      height: 50%;
      background: #ccc;
      border-radius: 50%;
      display: block;
    }
    .icon.text::before {
      content: "T";
      font-weight: bold;
      color: #666;
    }

    .canvas-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    .canvas {
      width: 900px;
      height: 600px;
      border: 1px solid #999;
      background-color: #fff;
      position: relative;
    }

    .shape {
      position: absolute;
      border: 2px solid black;
      display: flex;
      justify-content: center;
      align-items: center;
      box-sizing: border-box;
      transform-origin: center center;
      padding: 4px;
    }
    .shape.locked {
      pointer-events: none;
      opacity: 0.5;
    }
    .circle {
      border-radius: 50%;
    }
    .shape-text {
      min-width: 30px;
      min-height: 20px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .resize-handle {
      width: 10px;
      height: 10px;
      background: #333;
      position: absolute;
      right: -5px;
      bottom: -5px;
      cursor: nwse-resize;
    }
    .rotate-handle {
      width: 10px;
      height: 10px;
      background: #333;
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      cursor: grab;
      border-radius: 50%;
    }
    .selected {
      outline: 2px dashed blue;
    }
    .layers {
      flex: 1;
      overflow-y: auto;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 8px;
      margin-bottom: 10px;
    }
    .layer-item {
      padding: 4px 8px;
      margin: 4px 0;
      background: #eee;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .layer-item.selected {
      background: #d0ebff;
      outline: 1px solid #409eff;
    }
    .layer-controls {
      display: flex;
      gap: 4px;
    }
    .layer-btn {
      background: #ccc;
      border: none;
      padding: 2px 4px;
      cursor: pointer;
      border-radius: 4px;
    }
    .layer-btn:hover {
      background: #bbb;
    }
    .form-group#driveControls {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #ccc;
    }
    .drive-file {
      margin: 2px 0;
      cursor: pointer;
      padding: 4px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f9f9f9;
    }
    .drive-file:hover {
      background: #eee;
    }

    /* Additional: Delete button style */
    #deleteShape {
      background: #f44336;
      color: white;
      border: none;
      padding: 6px 12px;
      cursor: pointer;
      border-radius: 4px;
      margin-bottom: 10px;
    }
    #deleteShape:hover {
      background: #e03128;
    }
  </style>
</head>
<body>
  <div class="sidebar">
    <h2>Tools</h2>
    <div class="toolbar">
      <div class="icon rectangle" data-shape="rectangle" title="Rectangle"></div>
      <div class="icon circle" data-shape="circle" title="Circle"></div>
      <div class="icon text" data-shape="text" title="Text"></div>
    </div>
    <div class="form-group">
      <label for="colorPicker">Fill Color</label>
      <input type="color" id="colorPicker" value="#ff0000" />
    </div>
    <div class="form-group">
      <label for="fillOpacityRange">Fill Opacity</label>
      <input type="range" id="fillOpacityRange" min="0" max="1" step="0.1" value="1" />
    </div>
    <div class="form-group">
      <label for="borderColorPicker">Border Color</label>
      <input type="color" id="borderColorPicker" value="#000000" />
    </div>
    <div class="form-group">
      <label for="borderOpacityRange">Border Opacity</label>
      <input type="range" id="borderOpacityRange" min="0" max="1" step="0.1" value="1" />
    </div>
    <div class="form-group">
      <label for="borderWidth">Border Width</label>
      <input type="number" id="borderWidth" min="0" max="20" value="1" />
    </div>
    <div class="form-group">
      <label><input type="checkbox" id="snapToGrid" /> Snap to Grid</label>
    </div>
    <div class="form-group group-btn">
      <button id="groupShapes">Group</button>
      <button id="ungroupShapes">Ungroup</button>
    </div>
    <div class="form-group">
      <button id="undo">Undo</button>
      <button id="redo">Redo</button>
    </div>
    <div class="form-group">
      <button id="export">Export</button>
    </div>
    <button id="deleteShape">Delete Shape</button>

    <h3>Layers</h3>
    <div class="layers" id="layersList"></div>

    <!-- Drive Controls -->
    <div class="form-group" id="driveControls">
      <label>Google Drive Integration</label>
      <button id="authorize_button">Sign In</button>
      <button id="signout_button" style="display:none">Sign Out</button>
      <div id="driveFileList"></div>
    </div>
  </div>
  <div class="canvas-container">
    <div class="canvas"></div>
  </div>

  <script>
    // ====== Google Drive API Configuration ======
    // Fill in with your own client ID from Google Cloud Console
    const CLIENT_ID = "158627123477-4m4d7dqms8ndlmfq4mejhdguj1jte08m.apps.googleusercontent.com";
    const API_KEY = "AIzaSyABZW_c-XcHdnA-FwVOD5SxCXOtlmp9y4w"; // needed for listing files if using the Drive API
    const DISCOVERY_DOCS = ["https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"];
    const SCOPES = "https://www.googleapis.com/auth/drive.file";

    let currentFileId = null; // ID of the file in Drive

    // On load, load the auth2 library
    function gapiLoaded() {
      gapi.load('client:auth2', initClient);
    }

    async function initClient() {
      await gapi.client.init({
        apiKey: API_KEY,
        clientId: CLIENT_ID,
        discoveryDocs: DISCOVERY_DOCS,
        scope: SCOPES,
      });
      gapi.auth2.getAuthInstance().isSignedIn.listen(updateSigninStatus);
      updateSigninStatus(gapi.auth2.getAuthInstance().isSignedIn.get());
      document.getElementById('authorize_button').onclick = handleAuthClick;
      document.getElementById('signout_button').onclick = handleSignoutClick;
    }

    function updateSigninStatus(isSignedIn) {
      const authorizeButton = document.getElementById('authorize_button');
      const signoutButton = document.getElementById('signout_button');
      if (isSignedIn) {
        authorizeButton.style.display = 'none';
        signoutButton.style.display = 'block';
        listFiles();
      } else {
        authorizeButton.style.display = 'block';
        signoutButton.style.display = 'none';
      }
    }

    function handleAuthClick() {
      gapi.auth2.getAuthInstance().signIn();
    }

    function handleSignoutClick() {
      gapi.auth2.getAuthInstance().signOut();
      document.getElementById('driveFileList').innerHTML = '';
    }

    async function listFiles() {
      // List up to 10 HTML files in Drive (or all user files with 'file' mimeType)
      try {
        const response = await gapi.client.drive.files.list({
          pageSize: 10,
          fields: "files(id, name)",
          q: "mimeType != 'application/vnd.google-apps.folder'"
        });
        const files = response.result.files;
        const fileListElem = document.getElementById('driveFileList');
        fileListElem.innerHTML = '';
        if (files && files.length > 0) {
          files.forEach(file => {
            const div = document.createElement('div');
            div.classList.add('drive-file');
            div.textContent = file.name + ' (' + file.id + ')';
            div.addEventListener('click', () => {
              loadFromDrive(file.id);
            });
            fileListElem.appendChild(div);
          });
        } else {
          fileListElem.innerHTML = 'No files found.';
        }
      } catch (error) {
        console.error('Error listing files', error);
      }
    }

    async function loadFromDrive(fileId) {
      try {
        const response = await gapi.client.drive.files.get({
          fileId: fileId,
          alt: 'media'
        });
        const fileContent = response.body;
        // naive approach: load content into the canvas outerHTML
        // or parse JSON if needed.
        document.querySelector('.canvas-container').innerHTML = fileContent;
        currentFileId = fileId;
        // Might need re-initialization logic for shape events, etc.
        alert('File loaded from Drive.');
      } catch (error) {
        console.error('Error loading file', error);
      }
    }

    async function saveToDrive() {
      if (!currentFileId) {
        // create a new file
        await createFileOnDrive();
      } else {
        // update existing
        await updateFileOnDrive(currentFileId);
      }
    }

    async function createFileOnDrive() {
      try {
        const contentBlob = new Blob([document.querySelector('.canvas').outerHTML], { type: 'text/html' });
        const metadata = {
          name: 'drawing.html',
          mimeType: 'text/html'
        };

        const form = new FormData();
        form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
        form.append('file', contentBlob);

        const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
          method: 'POST',
          headers: new Headers({
            'Authorization': 'Bearer ' + gapi.auth.getToken().access_token
          }),
          body: form,
        });
        const result = await response.json();
        currentFileId = result.id;
        alert('File created on Drive: ' + currentFileId);
      } catch (error) {
        console.error('Error creating file', error);
      }
    }

    async function updateFileOnDrive(fileId) {
      try {
        const contentBlob = new Blob([document.querySelector('.canvas').outerHTML], { type: 'text/html' });
        const metadata = {
          name: 'drawing.html',
          mimeType: 'text/html'
        };

        const form = new FormData();
        form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
        form.append('file', contentBlob);

        await fetch('https://www.googleapis.com/upload/drive/v3/files/' + fileId + '?uploadType=multipart', {
          method: 'PATCH',
          headers: new Headers({
            'Authorization': 'Bearer ' + gapi.auth.getToken().access_token
          }),
          body: form,
        });
        alert('File updated on Drive.');
      } catch (error) {
        console.error('Error updating file', error);
      }
    }
    // ====== End Google Drive API Configuration ======
  </script>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      // Load Google API client after DOM
      if (window.gapi) {
        gapiLoaded();
      } else {
        console.warn("gapi not loaded yet");
      }

      // DOM Elements
      const canvas = document.querySelector(".canvas");
      const layersList = document.querySelector("#layersList");

      const colorPicker = document.querySelector("#colorPicker");
      const fillOpacityRange = document.querySelector("#fillOpacityRange");
      const borderColorPicker = document.querySelector("#borderColorPicker");
      const borderOpacityRange = document.querySelector("#borderOpacityRange");
      const borderWidthInput = document.querySelector("#borderWidth");
      const snapToGridCheckbox = document.querySelector("#snapToGrid");

      const groupBtn = document.querySelector("#groupShapes");
      const ungroupBtn = document.querySelector("#ungroupShapes");

      const undoButton = document.querySelector("#undo");
      const redoButton = document.querySelector("#redo");
      const exportButton = document.querySelector("#export");
      const shapeIcons = document.querySelectorAll(".icon");
      const deleteButton = document.querySelector("#deleteShape");

      // State
      let selectedShapeType = "rectangle";
      let shapes = []; // { id, element, type, zIndex }
      let redoStack = [];
      let isDrawing = false;
      let startX = 0;
      let startY = 0;
      let currentShape = null;

      let selectedFillColor = "#ff0000";
      let selectedFillOpacity = 1;
      let selectedBorderColor = "#000000";
      let selectedBorderOpacity = 1;
      let selectedBorderWidth = 1;

      // For multi-selection
      let selectedShapes = new Set();

      // Auto Save to Drive every 5 seconds if signed in
      setInterval(() => {
        if (gapi.auth2 && gapi.auth2.getAuthInstance() && gapi.auth2.getAuthInstance().isSignedIn.get()) {
          saveToDrive();
        }
      }, 5000);

      // ============ HELPER FUNCTIONS ============
      function generateId() {
        return "id-" + Math.random().toString(36).substr(2, 9);
      }

      function safeParseFloat(val, def = 1) {
        const parsed = parseFloat(val);
        return isNaN(parsed) ? def : parsed;
      }

      function hexToRgb(hex) {
        hex = hex.replace(/^#/, "");
        if (hex.length === 3) {
          const r = parseInt(hex[0] + hex[0], 16);
          const g = parseInt(hex[1] + hex[1], 16);
          const b = parseInt(hex[2] + hex[2], 16);
          return { r, g, b };
        } else if (hex.length === 6) {
          const r = parseInt(hex.substring(0, 2), 16);
          const g = parseInt(hex.substring(2, 4), 16);
          const b = parseInt(hex.substring(4, 6), 16);
          return { r, g, b };
        }
        return null;
      }

      function snap(value, gridSize) {
        return Math.round(value / gridSize) * gridSize;
      }

      // ============ LAYERS & RENDERING ============
      function renderLayers() {
        layersList.innerHTML = "";
        const sorted = [...shapes].sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));
        sorted.forEach(shape => {
          const div = document.createElement("div");
          div.classList.add("layer-item");
          if (selectedShapes.has(shape.id)) {
            div.classList.add("selected");
          }
          div.textContent = `${shape.type} (${shape.id})`;

          const controls = document.createElement("div");
          controls.classList.add("layer-controls");

          const upBtn = document.createElement("button");
          upBtn.classList.add("layer-btn");
          upBtn.textContent = "▲";
          upBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            bringForward(shape.id);
          });

          const downBtn = document.createElement("button");
          downBtn.classList.add("layer-btn");
          downBtn.textContent = "▼";
          downBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            sendBackward(shape.id);
          });

          controls.appendChild(upBtn);
          controls.appendChild(downBtn);
          div.appendChild(controls);

          div.addEventListener("click", (e) => {
            e.stopPropagation();
            if (!e.shiftKey) {
              selectedShapes.clear();
            }
            if (selectedShapes.has(shape.id)) {
              selectedShapes.delete(shape.id);
            } else {
              selectedShapes.add(shape.id);
            }
            updateSelectionUI();
            renderLayers();
          });
          layersList.appendChild(div);
        });
      }

      function updateSelectionUI() {
        shapes.forEach(s => s.element.classList.remove("selected"));
        shapes.forEach(s => {
          if (selectedShapes.has(s.id)) {
            s.element.classList.add("selected");
          }
        });
      }

      function bringForward(id) {
        const shapeObj = shapes.find(s => s.id === id);
        if (!shapeObj) return;
        shapeObj.zIndex++;
        reassignZIndices();
      }

      function sendBackward(id) {
        const shapeObj = shapes.find(s => s.id === id);
        if (!shapeObj) return;
        shapeObj.zIndex = Math.max(1, shapeObj.zIndex - 1);
        reassignZIndices();
      }

      function reassignZIndices() {
        shapes.sort((a, b) => (a.zIndex || 1) - (b.zIndex || 1));
        shapes.forEach((s, i) => {
          s.zIndex = i + 1;
          s.element.style.zIndex = s.zIndex;
        });
        renderLayers();
      }

      // ============ CREATE SHAPES ============
      function createNewShape() {
        const id = generateId();
        const el = document.createElement("div");
        el.classList.add("shape");
        if (selectedShapeType === "circle") {
          el.classList.add("circle");
        }
        const rgb = hexToRgb(selectedBorderColor) || { r: 0, g: 0, b: 0};
        el.style.backgroundColor = selectedFillColor;
        el.style.opacity = selectedFillOpacity;
        el.style.borderWidth = selectedBorderWidth + "px";
        el.style.borderStyle = "solid";
        el.style.borderColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${selectedBorderOpacity})`;
        el.style.left = startX + "px";
        el.style.top = startY + "px";
        el.style.width = "0px";
        el.style.height = "0px";
        el.dataset.id = id;
        addShapeEventListeners(el);

        const shapeObj = {
          id,
          element: el,
          type: selectedShapeType,
          zIndex: shapes.length + 1,
        };
        shapes.push(shapeObj);
        el.style.zIndex = shapeObj.zIndex;
        return shapeObj;
      }

      function createTextShape(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const id = generateId();
        const el = document.createElement("div");
        el.classList.add("shape", "shape-text");
        el.style.left = x + "px";
        el.style.top = y + "px";
        const rgb = hexToRgb(selectedBorderColor) || { r: 0, g: 0, b: 0};
        el.style.backgroundColor = selectedFillColor;
        el.style.opacity = selectedFillOpacity;
        el.style.borderWidth = selectedBorderWidth + "px";
        el.style.borderStyle = "solid";
        el.style.borderColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${selectedBorderOpacity})`;
        el.style.zIndex = shapes.length + 1;
        el.style.minWidth = "50px";
        el.style.minHeight = "20px";
        el.dataset.id = id;
        el.contentEditable = "true";
        el.innerText = "Your Text";
        addShapeEventListeners(el);
        canvas.appendChild(el);
        const shapeObj = {
          id,
          element: el,
          type: "text",
          zIndex: shapes.length + 1,
        };
        shapes.push(shapeObj);
        selectedShapes.clear();
        selectedShapes.add(id);
        updateSelectionUI();
        addResizeHandle(el);
        addRotateHandle(el);
        renderLayers();
      }

      function addShapeEventListeners(el) {
        el.addEventListener("mousedown", shapeMouseDown);
      }

      // ============ DRAGGING ============
      function shapeMouseDown(e) {
        if (isDrawing) return;
        const shapeEl = e.currentTarget;
        const shapeId = shapeEl.dataset.id;
        e.stopPropagation();
        if (!e.shiftKey && !selectedShapes.has(shapeId)) {
          selectedShapes.clear();
        }
        if (!selectedShapes.has(shapeId)) {
          selectedShapes.add(shapeId);
        }
        updateSelectionUI();
        renderLayers();

        let offsetX = e.offsetX;
        let offsetY = e.offsetY;

        function mouseMove(ev) {
          const cRect = canvas.getBoundingClientRect();
          let left = ev.clientX - cRect.left - offsetX;
          let top = ev.clientY - cRect.top - offsetY;
          if (snapToGridCheckbox.checked) {
            left = snap(left, 20);
            top = snap(top, 20);
          }
          selectedShapes.forEach(sId => {
            const sObj = shapes.find(obj => obj.id === sId);
            if (!sObj) return;
            const dx = parseInt(sObj.element.style.left) - parseInt(shapeEl.style.left);
            const dy = parseInt(sObj.element.style.top) - parseInt(shapeEl.style.top);
            sObj.element.style.left = (left + dx) + "px";
            sObj.element.style.top = (top + dy) + "px";
          });
        }

        function mouseUp() {
          document.removeEventListener("mousemove", mouseMove);
          document.removeEventListener("mouseup", mouseUp);
        }

        document.addEventListener("mousemove", mouseMove);
        document.addEventListener("mouseup", mouseUp);
      }

      // ============ RESIZING & ROTATION ============
      function addResizeHandle(shapeEl) {
        if (shapeEl.querySelector(".resize-handle")) return;
        const resize = document.createElement("div");
        resize.classList.add("resize-handle");
        shapeEl.appendChild(resize);

        resize.addEventListener("mousedown", e => {
          e.stopPropagation();
          let initialX = e.clientX;
          let initialY = e.clientY;
          let initialW = parseInt(shapeEl.style.width);
          let initialH = parseInt(shapeEl.style.height);
          let shapeLeft = parseInt(shapeEl.style.left);
          let shapeTop = parseInt(shapeEl.style.top);

          function onMouseMove(ev) {
            const deltaX = ev.clientX - initialX;
            const deltaY = ev.clientY - initialY;
            let newWidth = initialW + deltaX;
            let newHeight = initialH + deltaY;
            if (newWidth < 0) {
              shapeEl.style.left = (shapeLeft + newWidth) + "px";
              newWidth = Math.abs(newWidth);
            }
            if (newHeight < 0) {
              shapeEl.style.top = (shapeTop + newHeight) + "px";
              newHeight = Math.abs(newHeight);
            }
            if (ev.shiftKey) {
              const aspect = initialW / initialH || 1;
              if (Math.abs(deltaX) > Math.abs(deltaY)) {
                newHeight = newWidth / aspect;
              } else {
                newWidth = newHeight * aspect;
              }
            }
            if (snapToGridCheckbox.checked) {
              newWidth = snap(newWidth, 20);
              newHeight = snap(newHeight, 20);
            }
            shapeEl.style.width = newWidth + "px";
            shapeEl.style.height = newHeight + "px";
          }

          function onMouseUp() {
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", onMouseUp);
          }

          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", onMouseUp);
        });
      }

      function addRotateHandle(shapeEl) {
        if (shapeEl.querySelector(".rotate-handle")) return;
        const rotate = document.createElement("div");
        rotate.classList.add("rotate-handle");
        shapeEl.appendChild(rotate);

        rotate.addEventListener("mousedown", e => {
          e.stopPropagation();
          const rect = canvas.getBoundingClientRect();
          const centerX = shapeEl.offsetLeft + shapeEl.offsetWidth / 2;
          const centerY = shapeEl.offsetTop + shapeEl.offsetHeight / 2;

          function onMouseMove(ev) {
            const mouseX = ev.clientX - rect.left;
            const mouseY = ev.clientY - rect.top;
            const dx = mouseX - centerX;
            const dy = mouseY - centerY;
            let angle = Math.atan2(dy, dx) * (180 / Math.PI);
            shapeEl.style.transform = `translate(0,0) rotate(${angle}deg)`;
          }

          function onMouseUp() {
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", onMouseUp);
          }

          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", onMouseUp);
        });
      }

      // ============ GROUP & UNGROUP ============
      groupBtn.addEventListener("click", () => {
        if (selectedShapes.size < 2) return;
        const groupId = generateId();
        const groupEl = document.createElement("div");
        groupEl.classList.add("shape");
        groupEl.dataset.id = groupId;
        groupEl.dataset.isGroup = "true";
        groupEl.style.position = "absolute";
        groupEl.style.border = "2px dashed #444";
        canvas.appendChild(groupEl);

        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        const groupedShapes = [];
        shapes.forEach(s => {
          if (selectedShapes.has(s.id)) {
            const el = s.element;
            const x = parseInt(el.style.left);
            const y = parseInt(el.style.top);
            const w = parseInt(el.style.width) || el.offsetWidth;
            const h = parseInt(el.style.height) || el.offsetHeight;
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x + w > maxX) maxX = x + w;
            if (y + h > maxY) maxY = y + h;
            groupedShapes.push(s);
          }
        });
        const groupWidth = maxX - minX;
        const groupHeight = maxY - minY;
        groupEl.style.left = `${minX}px`;
        groupEl.style.top = `${minY}px`;
        groupEl.style.width = `${groupWidth}px`;
        groupEl.style.height = `${groupHeight}px`;

        groupedShapes.forEach(s => {
          const el = s.element;
          const shapeLeft = parseInt(el.style.left) - minX;
          const shapeTop = parseInt(el.style.top) - minY;
          el.style.left = shapeLeft + "px";
          el.style.top = shapeTop + "px";
          groupEl.appendChild(el);
        });

        shapes = shapes.filter(s => !selectedShapes.has(s.id));
        const groupObj = {
          id: groupId,
          element: groupEl,
          type: "group",
          zIndex: shapes.length + 1,
        };
        shapes.push(groupObj);
        groupEl.style.zIndex = groupObj.zIndex;
        selectedShapes.clear();
        selectedShapes.add(groupId);
        updateSelectionUI();
        renderLayers();
      });

      ungroupBtn.addEventListener("click", () => {
        if (selectedShapes.size !== 1) return;
        const id = [...selectedShapes][0];
        const shapeObj = shapes.find(s => s.id === id);
        if (!shapeObj || shapeObj.type !== "group") return;
        const groupEl = shapeObj.element;
        while (groupEl.firstChild) {
          const child = groupEl.firstChild;
          if (child.classList && child.classList.contains("shape")) {
            const offsetLeft = parseInt(groupEl.style.left);
            const offsetTop = parseInt(groupEl.style.top);
            const childLeft = parseInt(child.style.left) + offsetLeft;
            const childTop = parseInt(child.style.top) + offsetTop;
            child.style.left = childLeft + "px";
            child.style.top = childTop + "px";
            canvas.appendChild(child);
            const childId = child.dataset.id;
            const cShape = shapes.find(x => x.id === childId);
            if (!cShape) {
              // create new if we lost reference
              shapes.push({
                id: childId,
                element: child,
                type: child.classList.contains("circle") ? "circle" : child.classList.contains("shape-text") ? "text" : "rectangle",
                zIndex: shapes.length + 1,
              });
              child.style.zIndex = shapes.length;
            } else {
              cShape.zIndex = shapes.length + 1;
              child.style.zIndex = cShape.zIndex;
            }
          } else {
            groupEl.removeChild(child);
          }
        }
        shapes = shapes.filter(s => s.id !== id);
        groupEl.remove();
        selectedShapes.clear();
        renderLayers();
      });

      // ============ UNDO / REDO ============
      undoButton.addEventListener("click", () => {
        if (shapes.length > 0) {
          const last = shapes.pop();
          redoStack.push(last);
          last.element.remove();
          if (selectedShapes.has(last.id)) {
            selectedShapes.delete(last.id);
          }
          renderLayers();
        }
      });

      redoButton.addEventListener("click", () => {
        if (redoStack.length > 0) {
          const shapeObj = redoStack.pop();
          shapes.push(shapeObj);
          canvas.appendChild(shapeObj.element);
          reassignZIndices();
        }
      });

      // ============ EXPORT BUTTON ============
      exportButton.addEventListener("click", () => {
        const data = `<html>\n<body>\n${canvas.outerHTML}\n</body>\n</html>`;
        const blob = new Blob([data], { type: "text/html" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "drawing.html";
        a.click();
      });

      // ============ DELETE SHAPE ============
      deleteButton.addEventListener("click", () => {
        if (selectedShapes.size < 1) return;
        // Remove each selected shape from the DOM and from shapes array
        selectedShapes.forEach(sId => {
          const shapeObj = shapes.find(s => s.id === sId);
          if (shapeObj) {
            shapeObj.element.remove();
            shapes = shapes.filter(s => s.id !== sId);
          }
        });
        selectedShapes.clear();
        renderLayers();
      });

      // ============ EVENT LISTENERS FOR DRAWING ============
      shapeIcons.forEach(icon => {
        icon.addEventListener("click", () => {
          selectedShapeType = icon.getAttribute("data-shape");
        });
      });

      colorPicker.addEventListener("input", e => {
        selectedFillColor = e.target.value;
        selectedShapes.forEach(sId => {
          const sObj = shapes.find(obj => obj.id === sId);
          if (sObj && sObj.type !== "group") {
            sObj.element.style.backgroundColor = selectedFillColor;
          }
        });
      });

      fillOpacityRange.addEventListener("input", e => {
        selectedFillOpacity = safeParseFloat(e.target.value, 1);
        selectedShapes.forEach(sId => {
          const sObj = shapes.find(obj => obj.id === sId);
          if (sObj && sObj.type !== "group") {
            sObj.element.style.opacity = selectedFillOpacity;
          }
        });
      });

      borderColorPicker.addEventListener("input", e => {
        selectedBorderColor = e.target.value;
        selectedShapes.forEach(sId => {
          const sObj = shapes.find(obj => obj.id === sId);
          if (sObj && sObj.type !== "group") {
            const rgb = hexToRgb(selectedBorderColor);
            if (rgb) {
              // keep border opacity
              sObj.element.style.borderColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${selectedBorderOpacity})`;
            }
          }
        });
      });

      borderOpacityRange.addEventListener("input", e => {
        selectedBorderOpacity = safeParseFloat(e.target.value, 1);
        selectedShapes.forEach(sId => {
          const sObj = shapes.find(obj => obj.id === sId);
          if (sObj && sObj.type !== "group") {
            const rgb = hexToRgb(selectedBorderColor);
            if (rgb) {
              sObj.element.style.borderColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${selectedBorderOpacity})`;
            }
          }
        });
      });

      borderWidthInput.addEventListener("input", e => {
        selectedBorderWidth = parseInt(e.target.value);
        selectedShapes.forEach(sId => {
          const sObj = shapes.find(obj => obj.id === sId);
          if (sObj && sObj.type !== "group") {
            sObj.element.style.borderWidth = selectedBorderWidth + "px";
          }
        });
      });

      // ============ MOUSE EVENTS FOR CANVAS (CREATE SHAPE) ============
      canvas.addEventListener("mousedown", e => {
        // If text mode
        if (selectedShapeType === "text") {
          createTextShape(e);
          return;
        }
        const rect = canvas.getBoundingClientRect();
        startX = e.clientX - rect.left;
        startY = e.clientY - rect.top;
        isDrawing = true;
        currentShape = createNewShape();
        canvas.appendChild(currentShape.element);
        selectedShapes.clear();
        selectedShapes.add(currentShape.id);
        updateSelectionUI();
      });

      canvas.addEventListener("mousemove", e => {
        if (!isDrawing || !currentShape) return;
        const rect = canvas.getBoundingClientRect();
        let width = (e.clientX - rect.left) - parseInt(currentShape.element.style.left);
        let height = (e.clientY - rect.top) - parseInt(currentShape.element.style.top);
        if (snapToGridCheckbox.checked) {
          width = snap(width, 20);
          height = snap(height, 20);
        }
        currentShape.element.style.width = width + "px";
        currentShape.element.style.height = height + "px";
        if (currentShape.type === "circle") {
          currentShape.element.style.borderRadius = "50%";
        }
      });

      canvas.addEventListener("mouseup", e => {
        if (!isDrawing) return;
        isDrawing = false;
        if (currentShape) {
          const shapeLeft = parseInt(currentShape.element.style.left);
          const shapeTop = parseInt(currentShape.element.style.top);
          let shapeW = parseInt(currentShape.element.style.width);
          let shapeH = parseInt(currentShape.element.style.height);
          if (shapeW < 0) {
            currentShape.element.style.left = (shapeLeft + shapeW) + "px";
            currentShape.element.style.width = Math.abs(shapeW) + "px";
          }
          if (shapeH < 0) {
            currentShape.element.style.top = (shapeTop + shapeH) + "px";
            currentShape.element.style.height = Math.abs(shapeH) + "px";
          }
          addResizeHandle(currentShape.element);
          addRotateHandle(currentShape.element);
          currentShape = null;
        }
        reassignZIndices();
      });
    });
  </script>
</body>
</html>
